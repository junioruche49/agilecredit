{"version":3,"file":"react-query-hydration.min.mjs","sources":["../../src/hydration/hydration.ts","../../src/core/config.ts","../../src/hydration/react.tsx"],"sourcesContent":["import { DEFAULT_CACHE_TIME } from '../core/config'\n\nimport type { Query, QueryCache, QueryKey, QueryConfig } from 'react-query'\n\nexport interface DehydratedQueryConfig {\n  queryKey: QueryKey\n  cacheTime?: number\n  initialData?: unknown\n}\n\nexport interface DehydratedQuery {\n  config: DehydratedQueryConfig\n  updatedAt: number\n}\n\nexport interface DehydratedState {\n  queries: Array<DehydratedQuery>\n}\n\nexport type ShouldDehydrateFunction = <TResult, TError = unknown>(\n  query: Query<TResult, TError>\n) => boolean\nexport interface DehydrateConfig {\n  shouldDehydrate?: ShouldDehydrateFunction\n}\n\nfunction dehydrateQuery<TResult, TError = unknown>(\n  query: Query<TResult, TError>\n): DehydratedQuery {\n  const dehydratedQuery: DehydratedQuery = {\n    config: {\n      queryKey: query.queryKey,\n    },\n    updatedAt: query.state.updatedAt,\n  }\n\n  // Most config is not dehydrated but instead meant to configure again when\n  // consuming the de/rehydrated data, typically with useQuery on the client.\n  // Sometimes it might make sense to prefetch data on the server and include\n  // in the html-payload, but not consume it on the initial render.\n  // We still schedule stale and garbage collection right away, which means\n  // we need to specifically include staleTime and cacheTime in dehydration.\n  if (query.cacheTime !== DEFAULT_CACHE_TIME) {\n    dehydratedQuery.config.cacheTime = query.cacheTime\n  }\n  if (query.state.data !== undefined) {\n    dehydratedQuery.config.initialData = query.state.data\n  }\n\n  return dehydratedQuery\n}\n\nconst defaultShouldDehydrate: ShouldDehydrateFunction = query =>\n  query.state.status === 'success'\n\nexport function dehydrate(\n  queryCache: QueryCache,\n  dehydrateConfig?: DehydrateConfig\n): DehydratedState {\n  const config = dehydrateConfig || {}\n  const { shouldDehydrate = defaultShouldDehydrate } = config\n  const dehydratedState: DehydratedState = {\n    queries: [],\n  }\n  for (const query of queryCache.getQueries()) {\n    if (shouldDehydrate(query)) {\n      dehydratedState.queries.push(dehydrateQuery(query))\n    }\n  }\n\n  return dehydratedState\n}\n\nexport function hydrate<TResult>(\n  queryCache: QueryCache,\n  dehydratedState: unknown\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  for (const dehydratedQuery of queries) {\n    const queryKey = dehydratedQuery.config.queryKey\n    const queryConfig: QueryConfig<TResult> = dehydratedQuery.config as QueryConfig<\n      TResult\n    >\n\n    const query = queryCache.buildQuery(queryKey, queryConfig)\n    query.state.updatedAt = dehydratedQuery.updatedAt\n  }\n}\n","import { stableStringify } from './utils'\nimport {\n  ArrayQueryKey,\n  QueryKey,\n  QueryKeySerializerFunction,\n  ReactQueryConfig,\n  QueryConfig,\n  MutationConfig,\n} from './types'\n\n// TYPES\n\nexport interface ReactQueryConfigRef {\n  current: ReactQueryConfig\n}\n\n// CONFIG\n\nexport const defaultQueryKeySerializerFn: QueryKeySerializerFunction = (\n  queryKey: QueryKey\n): [string, ArrayQueryKey] => {\n  try {\n    let arrayQueryKey: ArrayQueryKey = Array.isArray(queryKey)\n      ? queryKey\n      : [queryKey]\n    const queryHash = stableStringify(arrayQueryKey)\n    arrayQueryKey = JSON.parse(queryHash)\n    return [queryHash, arrayQueryKey]\n  } catch {\n    throw new Error('A valid query key is required!')\n  }\n}\n\n/**\n * Config merging strategy\n *\n * When using hooks the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the hook query cache.\n * 3. Combined defaults from any config providers in the tree.\n * 4. Query/mutation config provided to the hook.\n *\n * When using a query cache directly the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the query cache.\n * 3. Query/mutation config provided to the query cache method.\n */\nexport const DEFAULT_STALE_TIME = 0\nexport const DEFAULT_CACHE_TIME = 5 * 60 * 1000\nexport const DEFAULT_CONFIG: ReactQueryConfig = {\n  queries: {\n    cacheTime: DEFAULT_CACHE_TIME,\n    enabled: true,\n    notifyOnStatusChange: true,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    refetchOnMount: true,\n    refetchOnReconnect: true,\n    refetchOnWindowFocus: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: DEFAULT_STALE_TIME,\n    structuralSharing: true,\n  },\n}\n\nexport function mergeReactQueryConfigs(\n  a: ReactQueryConfig,\n  b: ReactQueryConfig\n): ReactQueryConfig {\n  return {\n    shared: {\n      ...a.shared,\n      ...b.shared,\n    },\n    queries: {\n      ...a.queries,\n      ...b.queries,\n    },\n    mutations: {\n      ...a.mutations,\n      ...b.mutations,\n    },\n  }\n}\n\nexport function getDefaultedQueryConfig<TResult, TError>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: QueryConfig<TResult, TError>,\n  configOverrides?: QueryConfig<TResult, TError>\n): QueryConfig<TResult, TError> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.queries,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.queries,\n    ...contextConfig?.shared,\n    ...contextConfig?.queries,\n    ...config,\n    ...configOverrides,\n  } as QueryConfig<TResult, TError>\n}\n\nexport function getDefaultedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>,\n  configOverrides?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.mutations,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.mutations,\n    ...contextConfig?.shared,\n    ...contextConfig?.mutations,\n    ...config,\n    ...configOverrides,\n  } as MutationConfig<TResult, TError, TVariables, TSnapshot>\n}\n","import React from 'react'\nimport { useQueryCache } from 'react-query'\n\nimport { hydrate } from './hydration'\n\nexport function useHydrate(queries: unknown) {\n  const queryCache = useQueryCache()\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization\n  React.useMemo(() => {\n    if (queries) {\n      hydrate(queryCache, queries)\n    }\n    return undefined\n  }, [queryCache, queries])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n}\n\nexport const Hydrate: React.FC<HydrateProps> = ({ state, children }) => {\n  useHydrate(state)\n  return children as React.ReactElement<any>\n}\n"],"names":["defaultShouldDehydrate","query","state","status","dehydrate","queryCache","dehydrateConfig","dehydratedQuery","shouldDehydrate","dehydratedState","queries","getQueries","push","config","queryKey","updatedAt","cacheTime","undefined","data","initialData","hydrate","queryConfig","buildQuery","useHydrate","useQueryCache","React","useMemo","Hydrate","children"],"mappings":"s3BAoDA,IAAMA,EAAkD,SAAAC,SAC/B,YAAvBA,EAAMC,MAAMC,QAEP,SAASC,EACdC,EACAC,aA9BAL,EAEMM,KA8BSD,GAAmB,IAC1BE,gBAAAA,aAAkBR,IACpBS,EAAmC,CACvCC,QAAS,QAESL,EAAWM,6BAAc,KAAlCV,UACLO,EAAgBP,IAClBQ,EAAgBC,QAAQE,MArCtBL,OAAAA,EAAAA,EAAmC,CACvCM,OAAQ,CACNC,UAJJb,EAuCgDA,GAnC5Ba,UAElBC,UAAWd,EAAMC,MAAMa,WCiBO,MDR5Bd,EAAMe,YACRT,EAAgBM,OAAOG,UAAYf,EAAMe,gBAElBC,IAArBhB,EAAMC,MAAMgB,OACdX,EAAgBM,OAAOM,YAAclB,EAAMC,MAAMgB,MAG5CX,WAqBAE,EAGF,SAASW,EACdf,EACAI,MAE+B,iBAApBA,GAAoD,OAApBA,gBAI1BA,EAAoCC,SAAW,mBAEzB,KAA5BH,UACHO,EAAWP,EAAgBM,OAAOC,SAClCO,EAAoCd,EAAgBM,OAI5CR,EAAWiB,WAAWR,EAAUO,GACxCnB,MAAMa,UAAYR,EAAgBQ,WErFrC,SAASQ,EAAWb,OACnBL,EAAamB,IAKnBC,EAAMC,SAAQ,WACRhB,GACFU,EAAQf,EAAYK,KAGrB,CAACL,EAAYK,QAOLiB,EAAkC,gBAAGzB,IAAAA,MAAO0B,IAAAA,gBACvDL,EAAWrB,GACJ0B"}