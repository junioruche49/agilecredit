(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-query')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-query'], factory) :
  (global = global || self, factory(global.ReactQueryHydration = {}, global.React, global.ReactQuery));
}(this, (function (exports, React, reactQuery) { 'use strict';

  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }

  var DEFAULT_CACHE_TIME = 5 * 60 * 1000;

  function dehydrateQuery(query) {
    var dehydratedQuery = {
      config: {
        queryKey: query.queryKey
      },
      updatedAt: query.state.updatedAt
    }; // Most config is not dehydrated but instead meant to configure again when
    // consuming the de/rehydrated data, typically with useQuery on the client.
    // Sometimes it might make sense to prefetch data on the server and include
    // in the html-payload, but not consume it on the initial render.
    // We still schedule stale and garbage collection right away, which means
    // we need to specifically include staleTime and cacheTime in dehydration.

    if (query.cacheTime !== DEFAULT_CACHE_TIME) {
      dehydratedQuery.config.cacheTime = query.cacheTime;
    }

    if (query.state.data !== undefined) {
      dehydratedQuery.config.initialData = query.state.data;
    }

    return dehydratedQuery;
  }

  var defaultShouldDehydrate = function defaultShouldDehydrate(query) {
    return query.state.status === 'success';
  };

  function dehydrate(queryCache, dehydrateConfig) {
    var config = dehydrateConfig || {};
    var _config$shouldDehydra = config.shouldDehydrate,
        shouldDehydrate = _config$shouldDehydra === void 0 ? defaultShouldDehydrate : _config$shouldDehydra;
    var dehydratedState = {
      queries: []
    };

    for (var _iterator = _createForOfIteratorHelperLoose(queryCache.getQueries()), _step; !(_step = _iterator()).done;) {
      var _query = _step.value;

      if (shouldDehydrate(_query)) {
        dehydratedState.queries.push(dehydrateQuery(_query));
      }
    }

    return dehydratedState;
  }
  function hydrate(queryCache, dehydratedState) {
    if (typeof dehydratedState !== 'object' || dehydratedState === null) {
      return;
    }

    var queries = dehydratedState.queries || [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(queries), _step2; !(_step2 = _iterator2()).done;) {
      var dehydratedQuery = _step2.value;
      var queryKey = dehydratedQuery.config.queryKey;
      var queryConfig = dehydratedQuery.config;

      var _query2 = queryCache.buildQuery(queryKey, queryConfig);

      _query2.state.updatedAt = dehydratedQuery.updatedAt;
    }
  }

  function useHydrate(queries) {
    var queryCache = reactQuery.useQueryCache(); // Running hydrate again with the same queries is safe,
    // it wont overwrite or initialize existing queries,
    // relying on useMemo here is only a performance optimization

    React.useMemo(function () {
      if (queries) {
        hydrate(queryCache, queries);
      }

      return undefined;
    }, [queryCache, queries]);
  }
  var Hydrate = function Hydrate(_ref) {
    var state = _ref.state,
        children = _ref.children;
    useHydrate(state);
    return children;
  };

  exports.Hydrate = Hydrate;
  exports.dehydrate = dehydrate;
  exports.hydrate = hydrate;
  exports.useHydrate = useHydrate;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-query-hydration.development.js.map
