{"version":3,"file":"react-query-hydration.development.js","sources":["../../src/core/config.ts","../../src/hydration/hydration.ts","../../src/hydration/react.tsx"],"sourcesContent":["import { stableStringify } from './utils'\nimport {\n  ArrayQueryKey,\n  QueryKey,\n  QueryKeySerializerFunction,\n  ReactQueryConfig,\n  QueryConfig,\n  MutationConfig,\n} from './types'\n\n// TYPES\n\nexport interface ReactQueryConfigRef {\n  current: ReactQueryConfig\n}\n\n// CONFIG\n\nexport const defaultQueryKeySerializerFn: QueryKeySerializerFunction = (\n  queryKey: QueryKey\n): [string, ArrayQueryKey] => {\n  try {\n    let arrayQueryKey: ArrayQueryKey = Array.isArray(queryKey)\n      ? queryKey\n      : [queryKey]\n    const queryHash = stableStringify(arrayQueryKey)\n    arrayQueryKey = JSON.parse(queryHash)\n    return [queryHash, arrayQueryKey]\n  } catch {\n    throw new Error('A valid query key is required!')\n  }\n}\n\n/**\n * Config merging strategy\n *\n * When using hooks the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the hook query cache.\n * 3. Combined defaults from any config providers in the tree.\n * 4. Query/mutation config provided to the hook.\n *\n * When using a query cache directly the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the query cache.\n * 3. Query/mutation config provided to the query cache method.\n */\nexport const DEFAULT_STALE_TIME = 0\nexport const DEFAULT_CACHE_TIME = 5 * 60 * 1000\nexport const DEFAULT_CONFIG: ReactQueryConfig = {\n  queries: {\n    cacheTime: DEFAULT_CACHE_TIME,\n    enabled: true,\n    notifyOnStatusChange: true,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    refetchOnMount: true,\n    refetchOnReconnect: true,\n    refetchOnWindowFocus: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: DEFAULT_STALE_TIME,\n    structuralSharing: true,\n  },\n}\n\nexport function mergeReactQueryConfigs(\n  a: ReactQueryConfig,\n  b: ReactQueryConfig\n): ReactQueryConfig {\n  return {\n    shared: {\n      ...a.shared,\n      ...b.shared,\n    },\n    queries: {\n      ...a.queries,\n      ...b.queries,\n    },\n    mutations: {\n      ...a.mutations,\n      ...b.mutations,\n    },\n  }\n}\n\nexport function getDefaultedQueryConfig<TResult, TError>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: QueryConfig<TResult, TError>,\n  configOverrides?: QueryConfig<TResult, TError>\n): QueryConfig<TResult, TError> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.queries,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.queries,\n    ...contextConfig?.shared,\n    ...contextConfig?.queries,\n    ...config,\n    ...configOverrides,\n  } as QueryConfig<TResult, TError>\n}\n\nexport function getDefaultedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>,\n  configOverrides?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.mutations,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.mutations,\n    ...contextConfig?.shared,\n    ...contextConfig?.mutations,\n    ...config,\n    ...configOverrides,\n  } as MutationConfig<TResult, TError, TVariables, TSnapshot>\n}\n","import { DEFAULT_CACHE_TIME } from '../core/config'\n\nimport type { Query, QueryCache, QueryKey, QueryConfig } from 'react-query'\n\nexport interface DehydratedQueryConfig {\n  queryKey: QueryKey\n  cacheTime?: number\n  initialData?: unknown\n}\n\nexport interface DehydratedQuery {\n  config: DehydratedQueryConfig\n  updatedAt: number\n}\n\nexport interface DehydratedState {\n  queries: Array<DehydratedQuery>\n}\n\nexport type ShouldDehydrateFunction = <TResult, TError = unknown>(\n  query: Query<TResult, TError>\n) => boolean\nexport interface DehydrateConfig {\n  shouldDehydrate?: ShouldDehydrateFunction\n}\n\nfunction dehydrateQuery<TResult, TError = unknown>(\n  query: Query<TResult, TError>\n): DehydratedQuery {\n  const dehydratedQuery: DehydratedQuery = {\n    config: {\n      queryKey: query.queryKey,\n    },\n    updatedAt: query.state.updatedAt,\n  }\n\n  // Most config is not dehydrated but instead meant to configure again when\n  // consuming the de/rehydrated data, typically with useQuery on the client.\n  // Sometimes it might make sense to prefetch data on the server and include\n  // in the html-payload, but not consume it on the initial render.\n  // We still schedule stale and garbage collection right away, which means\n  // we need to specifically include staleTime and cacheTime in dehydration.\n  if (query.cacheTime !== DEFAULT_CACHE_TIME) {\n    dehydratedQuery.config.cacheTime = query.cacheTime\n  }\n  if (query.state.data !== undefined) {\n    dehydratedQuery.config.initialData = query.state.data\n  }\n\n  return dehydratedQuery\n}\n\nconst defaultShouldDehydrate: ShouldDehydrateFunction = query =>\n  query.state.status === 'success'\n\nexport function dehydrate(\n  queryCache: QueryCache,\n  dehydrateConfig?: DehydrateConfig\n): DehydratedState {\n  const config = dehydrateConfig || {}\n  const { shouldDehydrate = defaultShouldDehydrate } = config\n  const dehydratedState: DehydratedState = {\n    queries: [],\n  }\n  for (const query of queryCache.getQueries()) {\n    if (shouldDehydrate(query)) {\n      dehydratedState.queries.push(dehydrateQuery(query))\n    }\n  }\n\n  return dehydratedState\n}\n\nexport function hydrate<TResult>(\n  queryCache: QueryCache,\n  dehydratedState: unknown\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  for (const dehydratedQuery of queries) {\n    const queryKey = dehydratedQuery.config.queryKey\n    const queryConfig: QueryConfig<TResult> = dehydratedQuery.config as QueryConfig<\n      TResult\n    >\n\n    const query = queryCache.buildQuery(queryKey, queryConfig)\n    query.state.updatedAt = dehydratedQuery.updatedAt\n  }\n}\n","import React from 'react'\nimport { useQueryCache } from 'react-query'\n\nimport { hydrate } from './hydration'\n\nexport function useHydrate(queries: unknown) {\n  const queryCache = useQueryCache()\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization\n  React.useMemo(() => {\n    if (queries) {\n      hydrate(queryCache, queries)\n    }\n    return undefined\n  }, [queryCache, queries])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n}\n\nexport const Hydrate: React.FC<HydrateProps> = ({ state, children }) => {\n  useHydrate(state)\n  return children as React.ReactElement<any>\n}\n"],"names":["DEFAULT_CACHE_TIME","dehydrateQuery","query","dehydratedQuery","config","queryKey","updatedAt","state","cacheTime","data","undefined","initialData","defaultShouldDehydrate","status","dehydrate","queryCache","dehydrateConfig","shouldDehydrate","dehydratedState","queries","getQueries","push","hydrate","queryConfig","buildQuery","useHydrate","useQueryCache","React","useMemo","Hydrate","children"],"mappings":"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"}