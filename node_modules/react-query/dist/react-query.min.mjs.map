{"version":3,"file":"react-query.min.mjs","sources":["../src/core/types.ts","../src/core/utils.ts","../src/core/config.ts","../src/core/queryObserver.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/setFocusHandler.ts","../src/core/setOnlineHandler.ts","../src/react/ReactQueryCacheProvider.tsx","../src/react/ReactQueryConfigProvider.tsx","../src/react/useMutation.ts","../src/react/utils.ts","../src/react/useIsFetching.ts","../src/react/useDefaultedMutationConfig.tsx","../src/react/useBaseQuery.ts","../src/react/useDefaultedQueryConfig.tsx","../src/react/useQuery.ts","../src/react/usePaginatedQuery.ts","../src/react/useInfiniteQuery.ts"],"sourcesContent":["import type { FetchMoreOptions, RefetchOptions } from './query'\nimport type { QueryCache } from './queryCache'\n\nexport type QueryKey =\n  | boolean\n  | null\n  | number\n  | object\n  | string\n  | undefined\n  | { [key: number]: QueryKey }\n  | { [key: string]: QueryKey }\n  | readonly QueryKey[]\n\nexport type ArrayQueryKey = QueryKey[]\n\nexport type QueryFunction<TResult> = (\n  ...args: any[]\n) => TResult | Promise<TResult>\n\nexport type TypedQueryFunction<\n  TResult,\n  TArgs extends TypedQueryFunctionArgs = TypedQueryFunctionArgs\n> = (...args: TArgs) => TResult | Promise<TResult>\n\nexport type TypedQueryFunctionArgs = readonly [unknown, ...unknown[]]\n\nexport type InitialDataFunction<TResult> = () => TResult | undefined\n\nexport type InitialStaleFunction = () => boolean\n\nexport type QueryKeySerializerFunction = (\n  queryKey: QueryKey\n) => [string, QueryKey[]]\n\nexport interface BaseQueryConfig<TResult, TError = unknown, TData = TResult> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: boolean | number | ((failureCount: number, error: TError) => boolean)\n  retryDelay?: number | ((retryAttempt: number) => number)\n  staleTime?: number\n  cacheTime?: number\n  isDataEqual?: (oldData: unknown, newData: unknown) => boolean\n  queryFn?: QueryFunction<TData>\n  queryKey?: QueryKey\n  queryKeySerializerFn?: QueryKeySerializerFunction\n  queryFnParamsFilter?: (args: ArrayQueryKey) => ArrayQueryKey\n  initialData?: TResult | InitialDataFunction<TResult>\n  initialStale?: boolean | InitialStaleFunction\n  infinite?: true\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Defaults to `true`.\n   */\n  structuralSharing?: boolean\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `canFetchMore`.\n   */\n  getFetchMore?: (lastPage: TData, allPages: TData[]) => unknown\n}\n\nexport interface QueryObserverConfig<\n  TResult,\n  TError = unknown,\n  TData = TResult\n> extends BaseQueryConfig<TResult, TError, TData> {\n  /**\n   * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Defaults to `true`.\n   */\n  enabled?: boolean | unknown\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * Defaults to `false`.\n   */\n  refetchInterval?: number | false\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * Set this to `true` or `false` to enable/disable automatic refetching on window focus for this query.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?: boolean\n  /**\n   * Set this to `true` or `false` to enable/disable automatic refetching on reconnect for this query.\n   * Defaults to `true`.\n   */\n  refetchOnReconnect?: boolean\n  /**\n   * If set to `false`, will disable additional instances of a query to trigger background refetches.\n   * Defaults to `true`.\n   */\n  refetchOnMount?: boolean\n  /**\n   * Set this to `true` to always fetch when the component mounts (regardless of staleness).\n   * Defaults to `false`.\n   */\n  forceFetchOnMount?: boolean\n  /**\n   * Whether a change to the query status should re-render a component.\n   * If set to `false`, the component will only re-render when the actual `data` or `error` changes.\n   * Defaults to `true`.\n   */\n  notifyOnStatusChange?: boolean\n  /**\n   * This callback will fire any time the query successfully fetches new data.\n   */\n  onSuccess?: (data: TResult) => void\n  /**\n   * This callback will fire if the query encounters an error and will be passed the error.\n   */\n  onError?: (err: TError) => void\n  /**\n   * This callback will fire any time the query is either successfully fetched or errors and be passed either the data or error.\n   */\n  onSettled?: (data: TResult | undefined, error: TError | null) => void\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * Defaults to `false`.\n   */\n  useErrorBoundary?: boolean\n  /**\n   * If set to `true`, the query will suspend when `status === 'loading'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * Set this to `true` to keep the previous `data` when fetching based on a new query key.\n   * Defaults to `false`.\n   */\n  keepPreviousData?: boolean\n  /**\n   * By default the query cache from the context is used, but a different cache can be specified.\n   */\n  queryCache?: QueryCache\n}\n\nexport interface QueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface PaginatedQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface InfiniteQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult[], TError, TResult> {}\n\nexport type IsFetchingMoreValue = 'previous' | 'next' | false\n\nexport enum QueryStatus {\n  Idle = 'idle',\n  Loading = 'loading',\n  Error = 'error',\n  Success = 'success',\n}\n\nexport interface QueryResultBase<TResult, TError = unknown> {\n  canFetchMore: boolean | undefined\n  clear: () => void\n  data: TResult | undefined\n  error: TError | null\n  failureCount: number\n  fetchMore: (\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ) => Promise<TResult | undefined>\n  isError: boolean\n  isFetched: boolean\n  isFetchedAfterMount: boolean\n  isFetching: boolean\n  isFetchingMore?: IsFetchingMoreValue\n  isIdle: boolean\n  isLoading: boolean\n  isStale: boolean\n  isSuccess: boolean\n  isPreviousData: boolean\n  refetch: (options?: RefetchOptions) => Promise<TResult | undefined>\n  status: QueryStatus\n  updatedAt: number\n}\n\nexport interface QueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {}\n\nexport interface PaginatedQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {\n  resolvedData: TResult | undefined\n  latestData: TResult | undefined\n}\n\nexport interface InfiniteQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult[], TError> {}\n\nexport interface MutateConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> {\n  onSuccess?: (data: TResult, variables: TVariables) => Promise<void> | void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    snapshotValue: TSnapshot\n  ) => Promise<void> | void\n  onSettled?: (\n    data: undefined | TResult,\n    error: TError | null,\n    variables: TVariables,\n    snapshotValue?: TSnapshot\n  ) => Promise<void> | void\n  throwOnError?: boolean\n}\n\nexport interface MutationConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutateConfig<TResult, TError, TVariables, TSnapshot> {\n  onMutate?: (variables: TVariables) => Promise<TSnapshot> | TSnapshot\n  useErrorBoundary?: boolean\n  suspense?: boolean\n  /**\n   * By default the query cache from the context is used, but a different cache can be specified.\n   */\n  queryCache?: QueryCache\n}\n\nexport type MutationFunction<TResult, TVariables = unknown> = (\n  variables: TVariables\n) => Promise<TResult>\n\nexport type MutateFunction<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> = (\n  variables?: TVariables,\n  config?: MutateConfig<TResult, TError, TVariables, TSnapshot>\n) => Promise<TResult | undefined>\n\nexport type MutationResultPair<TResult, TError, TVariables, TSnapshot> = [\n  MutateFunction<TResult, TError, TVariables, TSnapshot>,\n  MutationResult<TResult, TError>\n]\n\nexport interface MutationResult<TResult, TError = unknown> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  reset: () => void\n}\n\nexport interface ReactQueryConfig<TResult = unknown, TError = unknown> {\n  queries?: ReactQueryQueriesConfig<TResult, TError>\n  shared?: ReactQuerySharedConfig\n  mutations?: ReactQueryMutationsConfig<TResult, TError>\n}\n\nexport interface ReactQuerySharedConfig {\n  suspense?: boolean\n}\n\nexport interface ReactQueryQueriesConfig<TResult, TError>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface ReactQueryMutationsConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutationConfig<TResult, TError, TVariables, TSnapshot> {}\n","import { QueryConfig, QueryStatus, QueryKey, QueryFunction } from './types'\n\n// TYPES\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\ntype ConsoleFunction = (...args: any[]) => void\n\nexport interface ConsoleObject {\n  log: ConsoleFunction\n  warn: ConsoleFunction\n  error: ConsoleFunction\n}\n\ninterface Cancelable {\n  cancel(): void\n}\n\nexport class CancelledError {}\n\n// UTILS\n\nlet _uid = 0\nexport const uid = () => _uid++\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): void {\n  return void 0\n}\n\nexport let Console: ConsoleObject = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function setConsole(c: ConsoleObject) {\n  Console = c\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nfunction stableStringifyReplacer(_key: string, value: any): unknown {\n  if (typeof value === 'function') {\n    throw new Error('Cannot stringify non JSON value')\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value)\n      .sort()\n      .reduce((result, key) => {\n        result[key] = value[key]\n        return result\n      }, {} as any)\n  }\n\n  return value\n}\n\nexport function stableStringify(value: any): string {\n  return JSON.stringify(value, stableStringifyReplacer)\n}\n\nexport function deepIncludes(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible(): boolean {\n  // document global can be unavailable in react native\n  if (typeof document === 'undefined') {\n    return true\n  }\n  return [undefined, 'visible', 'prerender'].includes(document.visibilityState)\n}\n\nexport function isOnline(): boolean {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs<TResult, TError, TOptions = undefined>(\n  args: any[]\n): [QueryKey, QueryConfig<TResult, TError>, TOptions] {\n  let queryKey: QueryKey\n  let queryFn: QueryFunction<TResult> | undefined\n  let config: QueryConfig<TResult, TError> | undefined\n  let options: TOptions\n\n  if (isObject(args[0])) {\n    queryKey = args[0].queryKey\n    queryFn = args[0].queryFn\n    config = args[0].config\n    options = args[1]\n  } else if (isObject(args[1])) {\n    queryKey = args[0]\n    config = args[1]\n    options = args[2]\n  } else {\n    queryKey = args[0]\n    queryFn = args[1]\n    config = args[2]\n    options = args[3]\n  }\n\n  config = config ? { queryKey, ...config } : { queryKey }\n\n  if (queryFn) {\n    config = { ...config, queryFn }\n  }\n\n  return [queryKey, config, options]\n}\n\nexport function deepEqual(a: any, b: any): boolean {\n  return replaceEqualDeep(a, b) === a\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = Array.isArray(a) && Array.isArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\nexport function isObject(a: unknown): boolean {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isCancelable(value: any): value is Cancelable {\n  return typeof value?.cancel === 'function'\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle,\n  }\n}\n\nexport function createSetHandler(fn: () => void) {\n  let removePreviousHandler: (() => void) | void\n  return (callback: (handler: () => void) => void) => {\n    // Unsub the old handler\n    if (removePreviousHandler) {\n      removePreviousHandler()\n    }\n    // Sub the new handler\n    removePreviousHandler = callback(fn)\n  }\n}\n","import { stableStringify } from './utils'\nimport {\n  ArrayQueryKey,\n  QueryKey,\n  QueryKeySerializerFunction,\n  ReactQueryConfig,\n  QueryConfig,\n  MutationConfig,\n} from './types'\n\n// TYPES\n\nexport interface ReactQueryConfigRef {\n  current: ReactQueryConfig\n}\n\n// CONFIG\n\nexport const defaultQueryKeySerializerFn: QueryKeySerializerFunction = (\n  queryKey: QueryKey\n): [string, ArrayQueryKey] => {\n  try {\n    let arrayQueryKey: ArrayQueryKey = Array.isArray(queryKey)\n      ? queryKey\n      : [queryKey]\n    const queryHash = stableStringify(arrayQueryKey)\n    arrayQueryKey = JSON.parse(queryHash)\n    return [queryHash, arrayQueryKey]\n  } catch {\n    throw new Error('A valid query key is required!')\n  }\n}\n\n/**\n * Config merging strategy\n *\n * When using hooks the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the hook query cache.\n * 3. Combined defaults from any config providers in the tree.\n * 4. Query/mutation config provided to the hook.\n *\n * When using a query cache directly the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the query cache.\n * 3. Query/mutation config provided to the query cache method.\n */\nexport const DEFAULT_STALE_TIME = 0\nexport const DEFAULT_CACHE_TIME = 5 * 60 * 1000\nexport const DEFAULT_CONFIG: ReactQueryConfig = {\n  queries: {\n    cacheTime: DEFAULT_CACHE_TIME,\n    enabled: true,\n    notifyOnStatusChange: true,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    refetchOnMount: true,\n    refetchOnReconnect: true,\n    refetchOnWindowFocus: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: DEFAULT_STALE_TIME,\n    structuralSharing: true,\n  },\n}\n\nexport function mergeReactQueryConfigs(\n  a: ReactQueryConfig,\n  b: ReactQueryConfig\n): ReactQueryConfig {\n  return {\n    shared: {\n      ...a.shared,\n      ...b.shared,\n    },\n    queries: {\n      ...a.queries,\n      ...b.queries,\n    },\n    mutations: {\n      ...a.mutations,\n      ...b.mutations,\n    },\n  }\n}\n\nexport function getDefaultedQueryConfig<TResult, TError>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: QueryConfig<TResult, TError>,\n  configOverrides?: QueryConfig<TResult, TError>\n): QueryConfig<TResult, TError> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.queries,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.queries,\n    ...contextConfig?.shared,\n    ...contextConfig?.queries,\n    ...config,\n    ...configOverrides,\n  } as QueryConfig<TResult, TError>\n}\n\nexport function getDefaultedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>,\n  configOverrides?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.mutations,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.mutations,\n    ...contextConfig?.shared,\n    ...contextConfig?.mutations,\n    ...config,\n    ...configOverrides,\n  } as MutationConfig<TResult, TError, TVariables, TSnapshot>\n}\n","import { getStatusProps, isServer, isDocumentVisible } from './utils'\nimport type { QueryResult, QueryObserverConfig } from './types'\nimport type { Query, Action, FetchMoreOptions, RefetchOptions } from './query'\nimport type { QueryCache } from './queryCache'\n\nexport type UpdateListener<TResult, TError> = (\n  result: QueryResult<TResult, TError>\n) => void\n\nexport class QueryObserver<TResult, TError> {\n  config: QueryObserverConfig<TResult, TError>\n\n  private queryCache: QueryCache\n  private currentQuery!: Query<TResult, TError>\n  private currentResult!: QueryResult<TResult, TError>\n  private previousQueryResult?: QueryResult<TResult, TError>\n  private updateListener?: UpdateListener<TResult, TError>\n  private initialFetchedCount: number\n  private staleTimeoutId?: number\n  private refetchIntervalId?: number\n  private started?: boolean\n\n  constructor(config: QueryObserverConfig<TResult, TError>) {\n    this.config = config\n    this.queryCache = config.queryCache!\n    this.initialFetchedCount = 0\n\n    // Bind exposed methods\n    this.clear = this.clear.bind(this)\n    this.refetch = this.refetch.bind(this)\n    this.fetchMore = this.fetchMore.bind(this)\n\n    // Subscribe to the query\n    this.updateQuery()\n  }\n\n  subscribe(listener?: UpdateListener<TResult, TError>): () => void {\n    this.started = true\n    this.updateListener = listener\n    this.currentQuery.subscribeObserver(this)\n\n    if (this.config.enabled && this.config.forceFetchOnMount) {\n      this.fetch()\n    } else {\n      this.optionalFetch()\n    }\n\n    this.updateTimers()\n    return this.unsubscribe.bind(this)\n  }\n\n  unsubscribe(): void {\n    this.started = false\n    this.updateListener = undefined\n    this.clearTimers()\n    this.currentQuery.unsubscribeObserver(this)\n  }\n\n  updateConfig(config: QueryObserverConfig<TResult, TError>): void {\n    const prevConfig = this.config\n    this.config = config\n\n    const updated = this.updateQuery()\n\n    // Take no further actions if the observer did not start yet\n    if (!this.started) {\n      return\n    }\n\n    // If we subscribed to a new query, optionally fetch and update refetch\n    if (updated) {\n      this.optionalFetch()\n      this.updateTimers()\n      return\n    }\n\n    // Optionally fetch if the query became enabled\n    if (config.enabled && !prevConfig.enabled) {\n      this.optionalFetch()\n    }\n\n    // Update stale interval if needed\n    if (\n      config.enabled !== prevConfig.enabled ||\n      config.staleTime !== prevConfig.staleTime\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    // Update refetch interval if needed\n    if (\n      config.enabled !== prevConfig.enabled ||\n      config.refetchInterval !== prevConfig.refetchInterval ||\n      config.refetchIntervalInBackground !==\n        prevConfig.refetchIntervalInBackground\n    ) {\n      this.updateRefetchInterval()\n    }\n  }\n\n  isStale(): boolean {\n    return this.currentResult.isStale\n  }\n\n  getCurrentQuery(): Query<TResult, TError> {\n    return this.currentQuery\n  }\n\n  getCurrentResult(): QueryResult<TResult, TError> {\n    return this.currentResult\n  }\n\n  clear(): void {\n    return this.currentQuery.clear()\n  }\n\n  async refetch(options?: RefetchOptions): Promise<TResult | undefined> {\n    return this.currentQuery.refetch(options, this.config)\n  }\n\n  async fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ): Promise<TResult | undefined> {\n    return this.currentQuery.fetchMore(fetchMoreVariable, options, this.config)\n  }\n\n  async fetch(): Promise<TResult | undefined> {\n    try {\n      return await this.currentQuery.fetch(undefined, this.config)\n    } catch {\n      // ignore\n    }\n  }\n\n  private optionalFetch(): void {\n    if (\n      this.config.enabled && // Don't auto refetch if disabled\n      !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched\n      this.currentResult.isStale && // Only refetch if stale\n      (this.config.refetchOnMount || this.currentQuery.observers.length === 1)\n    ) {\n      this.fetch()\n    }\n  }\n\n  private updateIsStale(): void {\n    const isStale = this.currentQuery.isStaleByTime(this.config.staleTime)\n    if (isStale !== this.currentResult.isStale) {\n      this.updateResult()\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    this.updateListener?.(this.currentResult)\n  }\n\n  private updateStaleTimeout(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearStaleTimeout()\n\n    const staleTime = this.config.staleTime || 0\n    const { isStale, updatedAt } = this.currentResult\n\n    if (isStale || staleTime === Infinity) {\n      return\n    }\n\n    const timeElapsed = Date.now() - updatedAt\n    const timeUntilStale = staleTime - timeElapsed\n    const timeout = Math.max(timeUntilStale, 0)\n\n    this.staleTimeoutId = setTimeout(() => {\n      this.updateIsStale()\n    }, timeout)\n  }\n\n  private updateRefetchInterval(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearRefetchInterval()\n\n    if (\n      !this.config.enabled ||\n      !this.config.refetchInterval ||\n      this.config.refetchInterval < 0 ||\n      this.config.refetchInterval === Infinity\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.config.refetchIntervalInBackground || isDocumentVisible()) {\n        this.fetch()\n      }\n    }, this.config.refetchInterval)\n  }\n\n  updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval()\n  }\n\n  clearTimers(): void {\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearInterval(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  private updateResult(): void {\n    const { currentQuery, currentResult, previousQueryResult, config } = this\n    const { state } = currentQuery\n    let { data, status, updatedAt } = state\n    let isPreviousData = false\n\n    // Keep previous data if needed\n    if (\n      config.keepPreviousData &&\n      (state.isIdle || state.isLoading) &&\n      previousQueryResult?.isSuccess\n    ) {\n      data = previousQueryResult.data\n      updatedAt = previousQueryResult.updatedAt\n      status = previousQueryResult.status\n      isPreviousData = true\n    }\n\n    let isStale = false\n\n    // When the query has not been fetched yet and this is the initial render,\n    // determine the staleness based on the initialStale or existence of initial data.\n    if (!currentResult && !state.isFetched) {\n      if (typeof config.initialStale === 'function') {\n        isStale = config.initialStale()\n      } else if (typeof config.initialStale === 'boolean') {\n        isStale = config.initialStale\n      } else {\n        isStale = typeof state.data === 'undefined'\n      }\n    } else {\n      isStale = currentQuery.isStaleByTime(config.staleTime)\n    }\n\n    this.currentResult = {\n      ...getStatusProps(status),\n      canFetchMore: state.canFetchMore,\n      clear: this.clear,\n      data,\n      error: state.error,\n      failureCount: state.failureCount,\n      fetchMore: this.fetchMore,\n      isFetched: state.isFetched,\n      isFetchedAfterMount: state.fetchedCount > this.initialFetchedCount,\n      isFetching: state.isFetching,\n      isFetchingMore: state.isFetchingMore,\n      isPreviousData,\n      isStale,\n      refetch: this.refetch,\n      updatedAt,\n    }\n  }\n\n  private updateQuery(): boolean {\n    const prevQuery = this.currentQuery\n\n    // Remove the initial data when there is an existing query\n    // because this data should not be used for a new query\n    const config =\n      this.config.keepPreviousData && prevQuery\n        ? { ...this.config, initialData: undefined }\n        : this.config\n\n    const newQuery = this.queryCache.buildQuery(config.queryKey, config)\n\n    if (newQuery === prevQuery) {\n      return false\n    }\n\n    this.previousQueryResult = this.currentResult\n    this.currentQuery = newQuery\n    this.initialFetchedCount = newQuery.state.fetchedCount\n    this.updateResult()\n\n    if (this.started) {\n      prevQuery?.unsubscribeObserver(this)\n      this.currentQuery.subscribeObserver(this)\n    }\n\n    return true\n  }\n\n  onQueryUpdate(action: Action<TResult, TError>): void {\n    // Store current result and get new result\n    const prevResult = this.currentResult\n    this.updateResult()\n\n    const { currentResult, config } = this\n\n    // We need to check the action because the state could have\n    // transitioned from success to success in case of `setQueryData`.\n    if (action.type === 'Success' && currentResult.isSuccess) {\n      config.onSuccess?.(currentResult.data!)\n      config.onSettled?.(currentResult.data!, null)\n      this.updateTimers()\n    } else if (action.type === 'Error' && currentResult.isError) {\n      config.onError?.(currentResult.error!)\n      config.onSettled?.(undefined, currentResult.error!)\n      this.updateTimers()\n    }\n\n    if (\n      // Always notify on data or error change\n      currentResult.data !== prevResult.data ||\n      currentResult.error !== prevResult.error ||\n      // Maybe notify on other changes\n      config.notifyOnStatusChange\n    ) {\n      this.notify()\n    }\n  }\n}\n","import {\n  CancelledError,\n  Console,\n  Updater,\n  functionalUpdate,\n  getStatusProps,\n  isCancelable,\n  isCancelledError,\n  isDocumentVisible,\n  isOnline,\n  isServer,\n  noop,\n  replaceEqualDeep,\n  sleep,\n} from './utils'\nimport {\n  ArrayQueryKey,\n  InitialDataFunction,\n  IsFetchingMoreValue,\n  QueryConfig,\n  QueryFunction,\n  QueryStatus,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport { QueryObserver, UpdateListener } from './queryObserver'\n\n// TYPES\n\ninterface QueryInitConfig<TResult, TError> {\n  queryCache: QueryCache\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  notifyGlobalListeners: (query: Query<TResult, TError>) => void\n}\n\nexport interface QueryState<TResult, TError> {\n  canFetchMore?: boolean\n  data?: TResult\n  error: TError | null\n  failureCount: number\n  fetchedCount: number\n  isError: boolean\n  isFetched: boolean\n  isFetching: boolean\n  isFetchingMore: IsFetchingMoreValue\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  status: QueryStatus\n  throwInErrorBoundary?: boolean\n  updatedAt: number\n}\n\ninterface FetchOptions {\n  fetchMore?: FetchMoreOptions\n}\n\nexport interface FetchMoreOptions {\n  fetchMoreVariable?: unknown\n  previous: boolean\n}\n\nexport interface RefetchOptions {\n  throwOnError?: boolean\n}\n\nexport enum ActionType {\n  Failed = 'Failed',\n  Fetch = 'Fetch',\n  Success = 'Success',\n  Error = 'Error',\n}\n\ninterface FailedAction {\n  type: ActionType.Failed\n}\n\ninterface FetchAction {\n  type: ActionType.Fetch\n  isFetchingMore?: IsFetchingMoreValue\n}\n\ninterface SuccessAction<TResult> {\n  type: ActionType.Success\n  data: TResult | undefined\n  canFetchMore?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: ActionType.Error\n  error: TError\n}\n\nexport type Action<TResult, TError> =\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | SuccessAction<TResult>\n\n// CLASS\n\nexport class Query<TResult, TError> {\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  observers: QueryObserver<TResult, TError>[]\n  state: QueryState<TResult, TError>\n  cacheTime: number\n\n  private queryCache: QueryCache\n  private promise?: Promise<TResult | undefined>\n  private gcTimeout?: number\n  private cancelFetch?: () => void\n  private continueFetch?: () => void\n  private isTransportCancelable?: boolean\n  private notifyGlobalListeners: (query: Query<TResult, TError>) => void\n\n  constructor(init: QueryInitConfig<TResult, TError>) {\n    this.config = init.config\n    this.queryCache = init.queryCache\n    this.queryKey = init.queryKey\n    this.queryHash = init.queryHash\n    this.notifyGlobalListeners = init.notifyGlobalListeners\n    this.observers = []\n    this.state = getDefaultState(init.config)\n    this.cacheTime = init.config.cacheTime!\n    this.scheduleGc()\n  }\n\n  private updateConfig(config: QueryConfig<TResult, TError>): void {\n    this.config = config\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime || 0)\n  }\n\n  private dispatch(action: Action<TResult, TError>): void {\n    this.state = queryReducer(this.state, action)\n\n    this.observers.forEach(observer => {\n      observer.onQueryUpdate(action)\n    })\n\n    this.notifyGlobalListeners(this)\n  }\n\n  private scheduleGc(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearGcTimeout()\n\n    if (this.cacheTime === Infinity || this.observers.length > 0) {\n      return\n    }\n\n    this.gcTimeout = setTimeout(() => {\n      this.clear()\n    }, this.cacheTime)\n  }\n\n  cancel(): void {\n    this.cancelFetch?.()\n  }\n\n  private continue(): void {\n    this.continueFetch?.()\n  }\n\n  private clearTimersObservers(): void {\n    this.observers.forEach(observer => {\n      observer.clearTimers()\n    })\n  }\n\n  private clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  setData(updater: Updater<TResult | undefined, TResult>): void {\n    const prevData = this.state.data\n\n    // Get the new data\n    let data: TResult | undefined = functionalUpdate(updater, prevData)\n\n    // Structurally share data between prev and new data if needed\n    if (this.config.structuralSharing) {\n      data = replaceEqualDeep(prevData, data)\n    }\n\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (this.config.isDataEqual?.(prevData, data)) {\n      data = prevData\n    }\n\n    // Try to determine if more data can be fetched\n    const canFetchMore = hasMorePages(this.config, data)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      type: ActionType.Success,\n      data,\n      canFetchMore,\n    })\n  }\n\n  clear(): void {\n    this.queryCache.removeQuery(this)\n  }\n\n  destroy(): void {\n    this.clearGcTimeout()\n    this.clearTimersObservers()\n    this.cancel()\n  }\n\n  isEnabled(): boolean {\n    return this.observers.some(observer => observer.config.enabled)\n  }\n\n  isStale(): boolean {\n    return this.observers.some(observer => observer.isStale())\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      !this.state.isSuccess || this.state.updatedAt + staleTime <= Date.now()\n    )\n  }\n\n  onInteraction(type: 'focus' | 'online'): void {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    const observer = this.observers.find(\n      observer =>\n        observer.isStale() &&\n        observer.config.enabled &&\n        ((observer.config.refetchOnWindowFocus && type === 'focus') ||\n          (observer.config.refetchOnReconnect && type === 'online'))\n    )\n\n    if (observer) {\n      observer.fetch().catch(noop)\n    }\n\n    // Continue any paused fetch\n    this.continue()\n  }\n\n  subscribe(\n    listener?: UpdateListener<TResult, TError>\n  ): QueryObserver<TResult, TError> {\n    const observer = new QueryObserver<TResult, TError>({\n      queryCache: this.queryCache,\n      queryKey: this.queryKey,\n      ...this.config,\n    })\n\n    observer.subscribe(listener)\n\n    return observer\n  }\n\n  subscribeObserver(observer: QueryObserver<TResult, TError>): void {\n    this.observers.push(observer)\n\n    // Stop the query from being garbage collected\n    this.clearGcTimeout()\n  }\n\n  unsubscribeObserver(observer: QueryObserver<TResult, TError>): void {\n    this.observers = this.observers.filter(x => x !== observer)\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel()\n      }\n    }\n\n    this.scheduleGc()\n  }\n\n  async refetch(\n    options?: RefetchOptions,\n    config?: QueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    try {\n      return await this.fetch(undefined, config)\n    } catch (error) {\n      if (options?.throwOnError === true) {\n        throw error\n      }\n    }\n  }\n\n  async fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions,\n    config?: QueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    return this.fetch(\n      {\n        fetchMore: {\n          fetchMoreVariable,\n          previous: options?.previous || false,\n        },\n      },\n      config\n    )\n  }\n\n  async fetch(\n    options?: FetchOptions,\n    config?: QueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    // If we are already fetching, return current promise\n    if (this.promise) {\n      return this.promise\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (config) {\n      this.updateConfig(config)\n    }\n\n    config = this.config\n\n    // Check if there is a query function\n    if (typeof config.queryFn !== 'function') {\n      return\n    }\n\n    // Get the query function params\n    const filter = config.queryFnParamsFilter\n    const params = filter ? filter(this.queryKey) : this.queryKey\n\n    this.promise = (async () => {\n      try {\n        let data: any\n\n        if (config.infinite) {\n          data = await this.startInfiniteFetch(config, params, options)\n        } else {\n          data = await this.startFetch(config, params, options)\n        }\n\n        // Set success state\n        this.setData(data)\n\n        // Cleanup\n        delete this.promise\n\n        // Return data\n        return data\n      } catch (error) {\n        // Set error state\n        this.dispatch({\n          type: ActionType.Error,\n          error,\n        })\n\n        // Log error\n        if (!isCancelledError(error)) {\n          Console.error(error)\n        }\n\n        // Cleanup\n        delete this.promise\n\n        // Propagate error\n        throw error\n      }\n    })()\n\n    return this.promise\n  }\n\n  private async startFetch(\n    config: QueryConfig<TResult, TError>,\n    params: unknown[],\n    _options?: FetchOptions\n  ): Promise<TResult> {\n    // Create function to fetch the data\n    const fetchData = () => config.queryFn!(...params)\n\n    // Set to fetching state if not already in it\n    if (!this.state.isFetching) {\n      this.dispatch({ type: ActionType.Fetch })\n    }\n\n    // Try to fetch the data\n    return this.tryFetchData(config, fetchData)\n  }\n\n  private async startInfiniteFetch(\n    config: QueryConfig<TResult, TError>,\n    params: unknown[],\n    options?: FetchOptions\n  ): Promise<TResult[]> {\n    const fetchMore = options?.fetchMore\n    const { previous, fetchMoreVariable } = fetchMore || {}\n    const isFetchingMore = fetchMore ? (previous ? 'previous' : 'next') : false\n    const prevPages: TResult[] = (this.state.data as any) || []\n\n    // Create function to fetch a page\n    const fetchPage = async (\n      pages: TResult[],\n      prepend?: boolean,\n      cursor?: unknown\n    ) => {\n      const lastPage = getLastPage(pages, prepend)\n\n      if (\n        typeof cursor === 'undefined' &&\n        typeof lastPage !== 'undefined' &&\n        config.getFetchMore\n      ) {\n        cursor = config.getFetchMore(lastPage, pages)\n      }\n\n      const page = await config.queryFn!(...params, cursor)\n\n      return prepend ? [page, ...pages] : [...pages, page]\n    }\n\n    // Create function to fetch the data\n    const fetchData = () => {\n      if (isFetchingMore) {\n        return fetchPage(prevPages, previous, fetchMoreVariable)\n      } else if (!prevPages.length) {\n        return fetchPage([])\n      } else {\n        let promise = fetchPage([])\n        for (let i = 1; i < prevPages.length; i++) {\n          promise = promise.then(fetchPage)\n        }\n        return promise\n      }\n    }\n\n    // Set to fetching state if not already in it\n    if (!this.state.isFetching) {\n      this.dispatch({ type: ActionType.Fetch, isFetchingMore })\n    }\n\n    // Try to get the data\n    return this.tryFetchData(config, fetchData)\n  }\n\n  private async tryFetchData<T>(\n    config: QueryConfig<TResult, TError>,\n    fn: QueryFunction<T>\n  ): Promise<T> {\n    return new Promise<T>((outerResolve, outerReject) => {\n      let resolved = false\n      let continueLoop: () => void\n      let cancelTransport: () => void\n\n      const done = () => {\n        resolved = true\n\n        delete this.cancelFetch\n        delete this.continueFetch\n        delete this.isTransportCancelable\n\n        // End loop if currently paused\n        continueLoop?.()\n      }\n\n      const resolve = (value: any) => {\n        done()\n        outerResolve(value)\n      }\n\n      const reject = (value: any) => {\n        done()\n        outerReject(value)\n      }\n\n      // Create callback to cancel this fetch\n      this.cancelFetch = () => {\n        reject(new CancelledError())\n        try {\n          cancelTransport?.()\n        } catch {}\n      }\n\n      // Create callback to continue this fetch\n      this.continueFetch = () => {\n        continueLoop?.()\n      }\n\n      // Create loop function\n      const run = async () => {\n        try {\n          // Execute query\n          const promiseOrValue = fn()\n\n          // Check if the transport layer support cancellation\n          if (isCancelable(promiseOrValue)) {\n            cancelTransport = () => {\n              promiseOrValue.cancel()\n            }\n            this.isTransportCancelable = true\n          }\n\n          // Await data\n          resolve(await promiseOrValue)\n        } catch (error) {\n          // Stop if the fetch is already resolved\n          if (resolved) {\n            return\n          }\n\n          // Do we need to retry the request?\n          const { failureCount } = this.state\n          const { retry, retryDelay } = config\n\n          const shouldRetry =\n            retry === true ||\n            failureCount < retry! ||\n            (typeof retry === 'function' && retry(failureCount, error))\n\n          if (!shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error)\n            return\n          }\n\n          // Increase the failureCount\n          this.dispatch({ type: ActionType.Failed })\n\n          // Delay\n          await sleep(functionalUpdate(retryDelay, failureCount) || 0)\n\n          // Pause retry if the document is not visible or when the device is offline\n          if (!isDocumentVisible() || !isOnline()) {\n            await new Promise(continueResolve => {\n              continueLoop = continueResolve\n            })\n          }\n\n          // Try again if not resolved yet\n          if (!resolved) {\n            run()\n          }\n        }\n      }\n\n      // Start loop\n      run()\n    })\n  }\n}\n\nfunction getLastPage<TResult>(pages: TResult[], previous?: boolean): TResult {\n  return previous ? pages[0] : pages[pages.length - 1]\n}\n\nfunction hasMorePages<TResult, TError>(\n  config: QueryConfig<TResult, TError>,\n  pages: unknown,\n  previous?: boolean\n): boolean | undefined {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages))\n  }\n}\n\nfunction getDefaultState<TResult, TError>(\n  config: QueryConfig<TResult, TError>\n): QueryState<TResult, TError> {\n  const initialData =\n    typeof config.initialData === 'function'\n      ? (config.initialData as InitialDataFunction<TResult>)()\n      : config.initialData\n\n  const hasInitialData = typeof initialData !== 'undefined'\n\n  const initialStatus = hasInitialData\n    ? QueryStatus.Success\n    : config.enabled\n    ? QueryStatus.Loading\n    : QueryStatus.Idle\n\n  return {\n    ...getStatusProps(initialStatus),\n    error: null,\n    isFetched: false,\n    isFetching: initialStatus === QueryStatus.Loading,\n    isFetchingMore: false,\n    failureCount: 0,\n    fetchedCount: 0,\n    data: initialData,\n    updatedAt: Date.now(),\n    canFetchMore: hasMorePages(config, initialData),\n  }\n}\n\nexport function queryReducer<TResult, TError>(\n  state: QueryState<TResult, TError>,\n  action: Action<TResult, TError>\n): QueryState<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Failed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case ActionType.Fetch:\n      const status =\n        typeof state.data !== 'undefined'\n          ? QueryStatus.Success\n          : QueryStatus.Loading\n      return {\n        ...state,\n        ...getStatusProps(status),\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        failureCount: 0,\n      }\n    case ActionType.Success:\n      return {\n        ...state,\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n        fetchedCount: state.fetchedCount + 1,\n        isFetched: true,\n        isFetching: false,\n        isFetchingMore: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case ActionType.Error:\n      return {\n        ...state,\n        ...getStatusProps(QueryStatus.Error),\n        error: action.error,\n        fetchedCount: state.fetchedCount + 1,\n        isFetched: true,\n        isFetching: false,\n        isFetchingMore: false,\n        failureCount: state.failureCount + 1,\n        throwInErrorBoundary: true,\n      }\n    default:\n      return state\n  }\n}\n","import {\n  Updater,\n  deepIncludes,\n  functionalUpdate,\n  getQueryArgs,\n  isDocumentVisible,\n  isObject,\n  isOnline,\n  isServer,\n} from './utils'\nimport { getDefaultedQueryConfig } from './config'\nimport { Query } from './query'\nimport {\n  QueryConfig,\n  QueryFunction,\n  QueryKey,\n  ReactQueryConfig,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from './types'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  frozen?: boolean\n  defaultConfig?: ReactQueryConfig\n}\n\ninterface ClearOptions {\n  notify?: boolean\n}\n\ninterface PrefetchQueryOptions {\n  force?: boolean\n  throwOnError?: boolean\n}\n\ninterface InvalidateQueriesOptions extends QueryPredicateOptions {\n  refetchActive?: boolean\n  refetchInactive?: boolean\n  throwOnError?: boolean\n}\n\ninterface QueryPredicateOptions {\n  exact?: boolean\n}\n\ntype QueryPredicate = QueryKey | QueryPredicateFn | true\n\ntype QueryPredicateFn = (query: Query<unknown, unknown>) => boolean\n\nexport interface PrefetchQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n  options?: PrefetchQueryOptions\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (\n  cache: QueryCache,\n  query?: Query<unknown, unknown>\n) => void\n\n// CLASS\n\nexport class QueryCache {\n  isFetching: number\n\n  private config: QueryCacheConfig\n  private globalListeners: QueryCacheListener[]\n  private queries: QueryHashMap\n  private queriesArray: Query<any, any>[]\n\n  constructor(config?: QueryCacheConfig) {\n    this.config = config || {}\n\n    // A frozen cache does not add new queries to the cache\n    this.globalListeners = []\n\n    this.queries = {}\n    this.queriesArray = []\n    this.isFetching = 0\n  }\n\n  private notifyGlobalListeners(query?: Query<any, any>) {\n    this.isFetching = this.getQueries().reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    this.globalListeners.forEach(listener => {\n      listener(this, query)\n    })\n  }\n\n  getDefaultConfig() {\n    return this.config.defaultConfig\n  }\n\n  getDefaultedQueryConfig<TResult, TError>(\n    config?: QueryConfig<TResult, TError>\n  ): QueryConfig<TResult, TError> {\n    return getDefaultedQueryConfig(this.getDefaultConfig(), undefined, config, {\n      queryCache: this,\n    })\n  }\n\n  subscribe(listener: QueryCacheListener): () => void {\n    this.globalListeners.push(listener)\n    return () => {\n      this.globalListeners = this.globalListeners.filter(x => x !== listener)\n    }\n  }\n\n  clear(options?: ClearOptions): void {\n    this.removeQueries()\n    if (options?.notify) {\n      this.notifyGlobalListeners()\n    }\n  }\n\n  getQueries<TResult = unknown, TError = unknown>(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): Query<TResult, TError>[] {\n    if (predicate === true || typeof predicate === 'undefined') {\n      return this.queriesArray\n    }\n\n    let predicateFn: QueryPredicateFn\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate as QueryPredicateFn\n    } else {\n      const config = this.getDefaultedQueryConfig()\n      const [queryHash, queryKey] = config.queryKeySerializerFn!(predicate)\n\n      predicateFn = d =>\n        options?.exact\n          ? d.queryHash === queryHash\n          : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return this.queriesArray.filter(predicateFn)\n  }\n\n  getQuery<TResult, TError = unknown>(\n    predicate: QueryPredicate\n  ): Query<TResult, TError> | undefined {\n    return this.getQueries<TResult, TError>(predicate, { exact: true })[0]\n  }\n\n  getQueryData<TResult>(predicate: QueryPredicate): TResult | undefined {\n    return this.getQuery<TResult>(predicate)?.state.data\n  }\n\n  removeQuery(query: Query<any, any>): void {\n    if (this.queries[query.queryHash]) {\n      query.destroy()\n      delete this.queries[query.queryHash]\n      this.queriesArray = this.queriesArray.filter(x => x !== query)\n      this.notifyGlobalListeners(query)\n    }\n  }\n\n  removeQueries(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => {\n      this.removeQuery(query)\n    })\n  }\n\n  cancelQueries(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => {\n      query.cancel()\n    })\n  }\n\n  async invalidateQueries(\n    predicate?: QueryPredicate,\n    options?: InvalidateQueriesOptions\n  ): Promise<void> {\n    const { refetchActive = true, refetchInactive = false, throwOnError } =\n      options || {}\n\n    try {\n      await Promise.all(\n        this.getQueries(predicate, options).map(query => {\n          const enabled = query.isEnabled()\n\n          if ((enabled && refetchActive) || (!enabled && refetchInactive)) {\n            return query.fetch()\n          }\n\n          return undefined\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  resetErrorBoundaries(): void {\n    this.getQueries().forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  buildQuery<TResult, TError = unknown>(\n    userQueryKey: QueryKey,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): Query<TResult, TError> {\n    const config = this.getDefaultedQueryConfig(queryConfig)\n    const [queryHash, queryKey] = config.queryKeySerializerFn!(userQueryKey)\n\n    if (this.queries[queryHash]) {\n      return this.queries[queryHash] as Query<TResult, TError>\n    }\n\n    const query = new Query<TResult, TError>({\n      queryCache: this,\n      queryKey,\n      queryHash,\n      config,\n      notifyGlobalListeners: query => {\n        this.notifyGlobalListeners(query)\n      },\n    })\n\n    if (!this.config.frozen) {\n      this.queries[queryHash] = query\n      this.queriesArray.push(query)\n      this.notifyGlobalListeners(query)\n    }\n\n    return query\n  }\n\n  // Parameter syntax with optional prefetch options\n  async prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function and optional prefetch options\n  async prefetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function, config and optional prefetch options\n  async prefetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Object syntax\n  async prefetchQuery<TResult = unknown, TError = unknown>(\n    config: PrefetchQueryObjectConfig<TResult, TError>\n  ): Promise<TResult | undefined>\n\n  // Implementation\n  async prefetchQuery<TResult, TError>(\n    ...args: any[]\n  ): Promise<TResult | undefined> {\n    if (\n      isObject(args[1]) &&\n      (args[1].hasOwnProperty('throwOnError') ||\n        args[1].hasOwnProperty('force'))\n    ) {\n      args[3] = args[1]\n      args[1] = undefined\n      args[2] = undefined\n    }\n\n    const [queryKey, config, options] = getQueryArgs<\n      TResult,\n      TError,\n      PrefetchQueryOptions | undefined\n    >(args)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    const configWithoutRetry = this.getDefaultedQueryConfig({\n      retry: false,\n      ...config,\n    })\n\n    let query\n    try {\n      query = this.buildQuery<TResult, TError>(queryKey, configWithoutRetry)\n      if (options?.force || query.isStaleByTime(config.staleTime)) {\n        await query.fetch(undefined, configWithoutRetry)\n      }\n      return query.state.data\n    } catch (error) {\n      if (options?.throwOnError) {\n        throw error\n      }\n    }\n  }\n\n  setQueryData<TResult, TError = unknown>(\n    queryKey: QueryKey,\n    updater: Updater<TResult | undefined, TResult>,\n    config?: QueryConfig<TResult, TError>\n  ) {\n    const query = this.getQuery<TResult, TError>(queryKey)\n\n    if (query) {\n      query.setData(updater)\n      return\n    }\n\n    this.buildQuery<TResult, TError>(queryKey, {\n      initialStale: typeof config?.staleTime === 'undefined',\n      initialData: functionalUpdate(updater, undefined),\n      ...config,\n    })\n  }\n}\n\nconst defaultQueryCache = makeQueryCache({ frozen: isServer })\nexport { defaultQueryCache as queryCache }\nexport const queryCaches = [defaultQueryCache]\n\nexport function makeQueryCache(config?: QueryCacheConfig) {\n  return new QueryCache(config)\n}\n\nexport function onVisibilityOrOnlineChange(type: 'focus' | 'online') {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache => {\n      queryCache.getQueries().forEach(query => {\n        query.onInteraction(type)\n      })\n    })\n  }\n}\n","import { createSetHandler, isServer } from './utils'\nimport { onVisibilityOrOnlineChange } from './queryCache'\n\nexport const setFocusHandler = createSetHandler(() =>\n  onVisibilityOrOnlineChange('focus')\n)\n\nsetFocusHandler(handleFocus => {\n  if (isServer || !window?.addEventListener) {\n    return\n  }\n\n  // Listen to visibillitychange and focus\n  window.addEventListener('visibilitychange', handleFocus, false)\n  window.addEventListener('focus', handleFocus, false)\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('visibilitychange', handleFocus)\n    window.removeEventListener('focus', handleFocus)\n  }\n})\n","import { createSetHandler, isServer } from './utils'\nimport { onVisibilityOrOnlineChange } from './queryCache'\n\nexport const setOnlineHandler = createSetHandler(() =>\n  onVisibilityOrOnlineChange('online')\n)\n\nsetOnlineHandler(handleOnline => {\n  if (isServer || !window?.addEventListener) {\n    return\n  }\n\n  // Listen to online\n  window.addEventListener('online', handleOnline, false)\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('online', handleOnline)\n  }\n})\n","import React from 'react'\n\nimport {\n  queryCache as defaultQueryCache,\n  queryCaches,\n  makeQueryCache,\n} from '../core'\nimport { QueryCache } from '../core/queryCache'\n\nexport const queryCacheContext = React.createContext(defaultQueryCache)\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport interface ReactQueryCacheProviderProps {\n  queryCache?: QueryCache\n}\n\nexport const ReactQueryCacheProvider: React.FC<ReactQueryCacheProviderProps> = ({\n  queryCache,\n  children,\n}) => {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear({ notify: false })\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { mergeReactQueryConfigs } from '../core/config'\nimport { ReactQueryConfig } from '../core/types'\n\nconst configContext = React.createContext<ReactQueryConfig | undefined>(\n  undefined\n)\n\nexport function useContextConfig() {\n  return React.useContext(configContext)\n}\n\nexport interface ReactQueryConfigProviderProps {\n  config: ReactQueryConfig\n}\n\nexport const ReactQueryConfigProvider: React.FC<ReactQueryConfigProviderProps> = ({\n  config,\n  children,\n}) => {\n  const parentConfig = useContextConfig()\n\n  const mergedConfig = React.useMemo(\n    () =>\n      parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config,\n    [config, parentConfig]\n  )\n\n  return (\n    <configContext.Provider value={mergedConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { useDefaultedMutationConfig } from './useDefaultedMutationConfig'\nimport { useGetLatest, useMountedCallback } from './utils'\nimport { Console, uid, getStatusProps } from '../core/utils'\nimport {\n  QueryStatus,\n  MutationResultPair,\n  MutationFunction,\n  MutationConfig,\n  MutateConfig,\n} from '../core/types'\n\n// TYPES\n\ntype Reducer<S, A> = (prevState: S, action: A) => S\n\ninterface State<TResult, TError> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n}\n\nenum ActionType {\n  Reset = 'Reset',\n  Loading = 'Loading',\n  Resolve = 'Resolve',\n  Reject = 'Reject',\n}\n\ninterface ResetAction {\n  type: ActionType.Reset\n}\n\ninterface LoadingAction {\n  type: ActionType.Loading\n}\n\ninterface ResolveAction<TResult> {\n  type: ActionType.Resolve\n  data: TResult\n}\n\ninterface RejectAction<TError> {\n  type: ActionType.Reject\n  error: TError\n}\n\ntype Action<TResult, TError> =\n  | ResetAction\n  | LoadingAction\n  | ResolveAction<TResult>\n  | RejectAction<TError>\n\n// HOOK\n\nconst getDefaultState = (): State<any, any> => ({\n  ...getStatusProps(QueryStatus.Idle),\n  data: undefined,\n  error: null,\n})\n\nfunction mutationReducer<TResult, TError>(\n  state: State<TResult, TError>,\n  action: Action<TResult, TError>\n): State<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Reset:\n      return getDefaultState()\n    case ActionType.Loading:\n      return {\n        ...getStatusProps(QueryStatus.Loading),\n        data: undefined,\n        error: null,\n      }\n    case ActionType.Resolve:\n      return {\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n      }\n    case ActionType.Reject:\n      return {\n        ...getStatusProps(QueryStatus.Error),\n        data: undefined,\n        error: action.error,\n      }\n    default:\n      return state\n  }\n}\n\nexport function useMutation<\n  TResult,\n  TError = unknown,\n  TVariables = undefined,\n  TSnapshot = unknown\n>(\n  mutationFn: MutationFunction<TResult, TVariables>,\n  config: MutationConfig<TResult, TError, TVariables, TSnapshot> = {}\n): MutationResultPair<TResult, TError, TVariables, TSnapshot> {\n  config = useDefaultedMutationConfig(config)\n  const getConfig = useGetLatest(config)\n\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer as Reducer<State<TResult, TError>, Action<TResult, TError>>,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const latestMutationRef = React.useRef<number>()\n\n  const mutate = React.useCallback(\n    async (\n      variables?: TVariables,\n      mutateConfig: MutateConfig<TResult, TError, TVariables, TSnapshot> = {}\n    ): Promise<TResult | undefined> => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      let snapshotValue: TSnapshot | undefined\n\n      try {\n        dispatch({ type: ActionType.Loading })\n        snapshotValue = (await config.onMutate?.(variables!)) as TSnapshot\n\n        const data = await getMutationFn()(variables!)\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Resolve, data })\n        }\n\n        await config.onSuccess?.(data, variables!)\n        await mutateConfig.onSuccess?.(data, variables!)\n        await config.onSettled?.(data, null, variables!)\n        await mutateConfig.onSettled?.(data, null, variables!)\n\n        return data\n      } catch (error) {\n        Console.error(error)\n        await config.onError?.(error, variables!, snapshotValue!)\n        await mutateConfig.onError?.(error, variables!, snapshotValue!)\n        await config.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue as TSnapshot\n        )\n        await mutateConfig.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue\n        )\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Reject, error })\n        }\n\n        if (mutateConfig.throwOnError ?? config.throwOnError) {\n          throw error\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => {\n    dispatch({ type: ActionType.Reset })\n  }, [dispatch])\n\n  React.useEffect(() => {\n    const { suspense, useErrorBoundary } = getConfig()\n\n    if ((useErrorBoundary ?? suspense) && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [mutate, { ...state, reset }]\n}\n","import React from 'react'\n\nimport { isServer } from '../core/utils'\n\nexport function useGetLatest<T>(obj: T): () => T {\n  const ref = React.useRef<T>(obj)\n  ref.current = obj\n  return React.useCallback(() => ref.current, [])\n}\n\nfunction useIsMounted(): () => boolean {\n  const mountedRef = React.useRef(false)\n  const isMounted = React.useCallback(() => mountedRef.current, [])\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mountedRef.current = true\n    return () => {\n      mountedRef.current = false\n    }\n  }, [])\n\n  return isMounted\n}\n\nexport function useMountedCallback<T extends Function>(callback: T): T {\n  const isMounted = useIsMounted()\n  return (React.useCallback(\n    (...args: any[]) => {\n      if (isMounted()) {\n        return callback(...args)\n      }\n    },\n    [callback, isMounted]\n  ) as any) as T\n}\n\n/**\n * This hook is a safe useState version which schedules state updates in microtasks\n * to prevent updating a component state while React is rendering different components\n * or when the component is not mounted anymore.\n */\nexport function useSafeState<S>(\n  initialState: S | (() => S)\n): [S, React.Dispatch<React.SetStateAction<S>>] {\n  const isMounted = useIsMounted()\n  const [state, setState] = React.useState(initialState)\n\n  const safeSetState = React.useCallback(\n    (value: React.SetStateAction<S>) => {\n      scheduleMicrotask(() => {\n        if (isMounted()) {\n          setState(value)\n        }\n      })\n    },\n    [isMounted]\n  )\n\n  return [state, safeSetState]\n}\n\nexport function useRerenderer() {\n  const [, setState] = useSafeState({})\n  return React.useCallback(() => setState({}), [setState])\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nfunction scheduleMicrotask(callback: () => void): void {\n  Promise.resolve()\n    .then(callback)\n    .catch(error =>\n      setTimeout(() => {\n        throw error\n      })\n    )\n}\n","import React from 'react'\n\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useSafeState } from './utils'\n\nexport function useIsFetching(): number {\n  const queryCache = useQueryCache()\n\n  const [isFetching, setIsFetching] = useSafeState(queryCache.isFetching)\n\n  React.useEffect(\n    () =>\n      queryCache.subscribe(() => {\n        setIsFetching(queryCache.isFetching)\n      }),\n    [queryCache, setIsFetching]\n  )\n\n  return isFetching\n}\n","import { MutationConfig } from '../core/types'\nimport { getDefaultedMutationConfig } from '../core/config'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\nexport function useDefaultedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  const contextConfig = useContextConfig()\n  const contextQueryCache = useQueryCache()\n  const queryCache = config?.queryCache || contextQueryCache\n  const queryCacheConfig = queryCache.getDefaultConfig()\n  return getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, {\n    queryCache,\n  })\n}\n","import React from 'react'\n\nimport { useRerenderer } from './utils'\nimport { QueryObserver } from '../core/queryObserver'\nimport { QueryResultBase, QueryObserverConfig } from '../core/types'\nimport { useDefaultedQueryConfig } from './useDefaultedQueryConfig'\n\nexport function useBaseQuery<TResult, TError>(\n  config: QueryObserverConfig<TResult, TError> = {}\n): QueryResultBase<TResult, TError> {\n  config = useDefaultedQueryConfig(config)\n\n  // Make a rerender function\n  const rerender = useRerenderer()\n\n  // Create query observer\n  const observerRef = React.useRef<QueryObserver<TResult, TError>>()\n  const firstRender = !observerRef.current\n  const observer = observerRef.current || new QueryObserver(config)\n  observerRef.current = observer\n\n  // Subscribe to the observer\n  React.useEffect(\n    () =>\n      observer.subscribe(() => {\n        rerender()\n      }),\n    [observer, rerender]\n  )\n\n  // Update config\n  if (!firstRender) {\n    observer.updateConfig(config)\n  }\n\n  const result = observer.getCurrentResult()\n\n  // Handle suspense\n  if (config.suspense || config.useErrorBoundary) {\n    const query = observer.getCurrentQuery()\n\n    if (result.isError && query.state.throwInErrorBoundary) {\n      throw result.error\n    }\n\n    if (config.enabled && config.suspense && !result.isSuccess) {\n      const unsubscribe = observer.subscribe()\n      throw observer.fetch().finally(unsubscribe)\n    }\n  }\n\n  return result\n}\n","import { QueryConfig } from '../core/types'\nimport { getDefaultedQueryConfig } from '../core/config'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\nexport function useDefaultedQueryConfig<TResult, TError>(\n  config?: QueryConfig<TResult, TError>\n): QueryConfig<TResult, TError> {\n  const contextConfig = useContextConfig()\n  const contextQueryCache = useQueryCache()\n  const queryCache = config?.queryCache || contextQueryCache\n  const queryCacheConfig = queryCache.getDefaultConfig()\n  return getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, {\n    queryCache,\n  })\n}\n","import {\n  QueryConfig,\n  QueryFunction,\n  QueryKey,\n  QueryResult,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// TYPES\n\nexport interface UseQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\nexport function useQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Object syntax\nexport function useQuery<TResult = unknown, TError = unknown>(\n  config: UseQueryObjectConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Implementation\nexport function useQuery<TResult, TError>(\n  ...args: any[]\n): QueryResult<TResult, TError> {\n  const config = getQueryArgs<TResult, TError>(args)[1]\n  return useBaseQuery<TResult, TError>(config)\n}\n","import {\n  PaginatedQueryConfig,\n  PaginatedQueryResult,\n  QueryFunction,\n  QueryKey,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// A paginated query is more like a \"lag\" query, which means\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n\n// TYPES\n\nexport interface UsePaginatedQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: PaginatedQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TArgs extends TypedQueryFunctionArgs\n>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Object syntax\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Implementation\nexport function usePaginatedQuery<TResult, TError>(\n  ...args: any[]\n): PaginatedQueryResult<TResult, TError> {\n  const config = getQueryArgs<TResult, TError>(args)[1]\n  const result = useBaseQuery<TResult, TError>({\n    keepPreviousData: true,\n    ...config,\n  })\n  return {\n    ...result,\n    resolvedData: result.data,\n    latestData: result.isPreviousData ? undefined : result.data,\n  }\n}\n","import {\n  InfiniteQueryConfig,\n  InfiniteQueryResult,\n  QueryFunction,\n  QueryKey,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// TYPES\n\nexport interface UseInfiniteQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: InfiniteQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TArgs extends TypedQueryFunctionArgs\n>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Object syntax\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Implementation\nexport function useInfiniteQuery<TResult, TError>(\n  ...args: any[]\n): InfiniteQueryResult<TResult, TError> {\n  const config = getQueryArgs<TResult[], TError>(args)[1]\n  return useBaseQuery<TResult[], TError>({ ...config, infinite: true })\n}\n"],"names":["QueryStatus","CancelledError","_uid","isServer","window","noop","Console","console","error","warn","log","setConsole","c","functionalUpdate","updater","input","stableStringifyReplacer","_key","value","Error","isObject","Object","keys","sort","reduce","result","key","isDocumentVisible","document","undefined","includes","visibilityState","isOnline","navigator","onLine","getQueryArgs","args","queryKey","queryFn","config","options","a","Array","isArray","isPlainObject","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","isError","isCancelledError","getStatusProps","status","isLoading","Loading","isSuccess","Success","isIdle","Idle","createSetHandler","fn","removePreviousHandler","callback","DEFAULT_CONFIG","queries","cacheTime","enabled","notifyOnStatusChange","queryKeySerializerFn","arrayQueryKey","queryHash","JSON","stringify","parse","refetchOnMount","refetchOnReconnect","refetchOnWindowFocus","retry","retryDelay","attemptIndex","Math","min","staleTime","structuralSharing","getDefaultedQueryConfig","queryCacheConfig","contextConfig","configOverrides","shared","then","direct","Promise","resolve","ActionType","QueryObserver","queryCache","initialFetchedCount","clear","this","bind","refetch","fetchMore","updateQuery","subscribe","listener","started","updateListener","currentQuery","subscribeObserver","forceFetchOnMount","fetch","optionalFetch","updateTimers","unsubscribe","clearTimers","unsubscribeObserver","updateConfig","prevConfig","updated","updateStaleTimeout","refetchInterval","refetchIntervalInBackground","updateRefetchInterval","isStale","currentResult","getCurrentQuery","getCurrentResult","fetchMoreVariable","body","recover","e","_this5","suspense","isFetched","observers","length","updateIsStale","isStaleByTime","updateResult","notify","clearStaleTimeout","updatedAt","Infinity","timeUntilStale","Date","now","timeout","max","staleTimeoutId","setTimeout","_this6","clearRefetchInterval","refetchIntervalId","setInterval","_this7","clearInterval","previousQueryResult","state","data","isPreviousData","keepPreviousData","initialStale","canFetchMore","failureCount","isFetchedAfterMount","fetchedCount","isFetching","isFetchingMore","prevQuery","initialData","newQuery","buildQuery","onQueryUpdate","action","prevResult","type","onSuccess","onSettled","onError","f","i","arguments","apply","reject","Query","init","initialStatus","notifyGlobalListeners","hasMorePages","scheduleGc","dispatch","Failed","Fetch","throwInErrorBoundary","queryReducer","forEach","observer","clearGcTimeout","gcTimeout","_this","cancel","cancelFetch","continue","continueFetch","clearTimersObservers","clearTimeout","setData","prevData","replaceEqualDeep","b","array","aSize","bItems","bSize","copy","equalItems","isDataEqual","_this$config$isDataEq","removeQuery","destroy","isEnabled","some","onInteraction","find","catch","push","filter","x","isTransportCancelable","_this3","throwOnError","previous","promise","queryFnParamsFilter","params","_async","infinite","startInfiniteFetch","startFetch","_options","tryFetchData","prevPages","fetchPage","pages","prepend","cursor","lastPage","getLastPage","getFetchMore","page","outerResolve","outerReject","continueLoop","cancelTransport","resolved","done","_this13","run","promiseOrValue","continueResolve","Boolean","QueryCache","globalListeners","queriesArray","query","getQueries","acc","getDefaultConfig","defaultConfig","_this2","removeQueries","predicate","predicateFn","d","exact","deepIncludes","getQuery","getQueryData","_this$getQuery","cancelQueries","invalidateQueries","refetchActive","refetchInactive","all","map","err","resetErrorBoundaries","userQueryKey","queryConfig","frozen","prefetchQuery","configWithoutRetry","_this8","force","setQueryData","defaultQueryCache","makeQueryCache","queryCaches","onVisibilityOrOnlineChange","setFocusHandler","handleFocus","_window","addEventListener","removeEventListener","setOnlineHandler","handleOnline","queryCacheContext","React","createContext","useQueryCache","useContext","ReactQueryCacheProvider","children","resolvedQueryCache","useMemo","useEffect","indexOf","splice","Provider","configContext","useContextConfig","ReactQueryConfigProvider","parentConfig","mergedConfig","mutations","useGetLatest","obj","ref","useRef","current","useCallback","useIsMounted","mountedRef","isMounted","useSafeState","initialState","useState","setState","useIsFetching","setIsFetching","useDefaultedMutationConfig","contextQueryCache","getDefaultedMutationConfig","_await","getDefaultState","mutationReducer","Reset","Resolve","Reject","useMutation","mutationFn","getConfig","useReducer","unsafeDispatch","getMutationFn","latestMutationRef","mutate","variables","mutateConfig","mutationId","snapshotValue","isLatest","onMutate","reset","useErrorBoundary","useBaseQuery","useDefaultedQueryConfig","rerender","observerRef","firstRender","finally","useQuery","usePaginatedQuery","resolvedData","latestData","useInfiniteQuery"],"mappings":"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"}