import React from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var QueryStatus;

(function (QueryStatus) {
  QueryStatus["Idle"] = "idle";
  QueryStatus["Loading"] = "loading";
  QueryStatus["Error"] = "error";
  QueryStatus["Success"] = "success";
})(QueryStatus || (QueryStatus = {}));

var CancelledError = function CancelledError() {}; // UTILS

var _uid = 0;
var uid = function uid() {
  return _uid++;
};
var isServer = typeof window === 'undefined';
function noop() {
  return void 0;
}
var Console = console || {
  error: noop,
  warn: noop,
  log: noop
};
function setConsole(c) {
  Console = c;
}
function functionalUpdate(updater, input) {
  return typeof updater === 'function' ? updater(input) : updater;
}

function stableStringifyReplacer(_key, value) {
  if (typeof value === 'function') {
    throw new Error('Cannot stringify non JSON value');
  }

  if (isObject(value)) {
    return Object.keys(value).sort().reduce(function (result, key) {
      result[key] = value[key];
      return result;
    }, {});
  }

  return value;
}

function stableStringify(value) {
  return JSON.stringify(value, stableStringifyReplacer);
}
function deepIncludes(a, b) {
  if (a === b) {
    return true;
  }

  if (typeof a !== typeof b) {
    return false;
  }

  if (typeof a === 'object') {
    return !Object.keys(b).some(function (key) {
      return !deepIncludes(a[key], b[key]);
    });
  }

  return false;
}
function isDocumentVisible() {
  // document global can be unavailable in react native
  if (typeof document === 'undefined') {
    return true;
  }

  return [undefined, 'visible', 'prerender'].includes(document.visibilityState);
}
function isOnline() {
  return navigator.onLine === undefined || navigator.onLine;
}
function getQueryArgs(args) {
  var queryKey;
  var queryFn;
  var config;
  var options;

  if (isObject(args[0])) {
    queryKey = args[0].queryKey;
    queryFn = args[0].queryFn;
    config = args[0].config;
    options = args[1];
  } else if (isObject(args[1])) {
    queryKey = args[0];
    config = args[1];
    options = args[2];
  } else {
    queryKey = args[0];
    queryFn = args[1];
    config = args[2];
    options = args[3];
  }

  config = config ? _extends({
    queryKey: queryKey
  }, config) : {
    queryKey: queryKey
  };

  if (queryFn) {
    config = _extends({}, config, {
      queryFn: queryFn
    });
  }

  return [queryKey, config, options];
}
/**
 * This function returns `a` if `b` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between JSON values for example.
 */

function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }

  var array = Array.isArray(a) && Array.isArray(b);

  if (array || isPlainObject(a) && isPlainObject(b)) {
    var aSize = array ? a.length : Object.keys(a).length;
    var bItems = array ? b : Object.keys(b);
    var bSize = bItems.length;
    var copy = array ? [] : {};
    var equalItems = 0;

    for (var i = 0; i < bSize; i++) {
      var key = array ? i : bItems[i];
      copy[key] = replaceEqualDeep(a[key], b[key]);

      if (copy[key] === a[key]) {
        equalItems++;
      }
    }

    return aSize === bSize && equalItems === aSize ? a : copy;
  }

  return b;
}
function isObject(a) {
  return a && typeof a === 'object' && !Array.isArray(a);
} // Copied from: https://github.com/jonschlinkert/is-plain-object

function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  } // If has modified constructor


  var ctor = o.constructor;

  if (typeof ctor === 'undefined') {
    return true;
  } // If has modified prototype


  var prot = ctor.prototype;

  if (!hasObjectPrototype(prot)) {
    return false;
  } // If constructor does not have an Object-specific method


  if (!prot.hasOwnProperty('isPrototypeOf')) {
    return false;
  } // Most likely a plain Object


  return true;
}

function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isCancelable(value) {
  return typeof (value == null ? void 0 : value.cancel) === 'function';
}
function isError(value) {
  return value instanceof Error;
}
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function sleep(timeout) {
  return new Promise(function (resolve) {
    setTimeout(resolve, timeout);
  });
}
function getStatusProps(status) {
  return {
    status: status,
    isLoading: status === QueryStatus.Loading,
    isSuccess: status === QueryStatus.Success,
    isError: status === QueryStatus.Error,
    isIdle: status === QueryStatus.Idle
  };
}
function createSetHandler(fn) {
  var removePreviousHandler;
  return function (callback) {
    // Unsub the old handler
    if (removePreviousHandler) {
      removePreviousHandler();
    } // Sub the new handler


    removePreviousHandler = callback(fn);
  };
}

// CONFIG
var defaultQueryKeySerializerFn = function defaultQueryKeySerializerFn(queryKey) {
  try {
    var arrayQueryKey = Array.isArray(queryKey) ? queryKey : [queryKey];
    var queryHash = stableStringify(arrayQueryKey);
    arrayQueryKey = JSON.parse(queryHash);
    return [queryHash, arrayQueryKey];
  } catch (_unused) {
    throw new Error('A valid query key is required!');
  }
};
/**
 * Config merging strategy
 *
 * When using hooks the config will be merged in the following order:
 *
 * 1. These defaults.
 * 2. Defaults from the hook query cache.
 * 3. Combined defaults from any config providers in the tree.
 * 4. Query/mutation config provided to the hook.
 *
 * When using a query cache directly the config will be merged in the following order:
 *
 * 1. These defaults.
 * 2. Defaults from the query cache.
 * 3. Query/mutation config provided to the query cache method.
 */

var DEFAULT_STALE_TIME = 0;
var DEFAULT_CACHE_TIME = 5 * 60 * 1000;
var DEFAULT_CONFIG = {
  queries: {
    cacheTime: DEFAULT_CACHE_TIME,
    enabled: true,
    notifyOnStatusChange: true,
    queryKeySerializerFn: defaultQueryKeySerializerFn,
    refetchOnMount: true,
    refetchOnReconnect: true,
    refetchOnWindowFocus: true,
    retry: 3,
    retryDelay: function retryDelay(attemptIndex) {
      return Math.min(1000 * Math.pow(2, attemptIndex), 30000);
    },
    staleTime: DEFAULT_STALE_TIME,
    structuralSharing: true
  }
};
function mergeReactQueryConfigs(a, b) {
  return {
    shared: _extends({}, a.shared, b.shared),
    queries: _extends({}, a.queries, b.queries),
    mutations: _extends({}, a.mutations, b.mutations)
  };
}
function getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, configOverrides) {
  return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.queries, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.queries, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.queries, config, configOverrides);
}
function getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, configOverrides) {
  return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.mutations, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.mutations, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.mutations, config, configOverrides);
}

function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

function _empty() {}

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

var QueryObserver = /*#__PURE__*/function () {
  function QueryObserver(config) {
    this.config = config;
    this.queryCache = config.queryCache;
    this.initialFetchedCount = 0; // Bind exposed methods

    this.clear = this.clear.bind(this);
    this.refetch = this.refetch.bind(this);
    this.fetchMore = this.fetchMore.bind(this); // Subscribe to the query

    this.updateQuery();
  }

  var _proto = QueryObserver.prototype;

  _proto.subscribe = function subscribe(listener) {
    this.started = true;
    this.updateListener = listener;
    this.currentQuery.subscribeObserver(this);

    if (this.config.enabled && this.config.forceFetchOnMount) {
      this.fetch();
    } else {
      this.optionalFetch();
    }

    this.updateTimers();
    return this.unsubscribe.bind(this);
  };

  _proto.unsubscribe = function unsubscribe() {
    this.started = false;
    this.updateListener = undefined;
    this.clearTimers();
    this.currentQuery.unsubscribeObserver(this);
  };

  _proto.updateConfig = function updateConfig(config) {
    var prevConfig = this.config;
    this.config = config;
    var updated = this.updateQuery(); // Take no further actions if the observer did not start yet

    if (!this.started) {
      return;
    } // If we subscribed to a new query, optionally fetch and update refetch


    if (updated) {
      this.optionalFetch();
      this.updateTimers();
      return;
    } // Optionally fetch if the query became enabled


    if (config.enabled && !prevConfig.enabled) {
      this.optionalFetch();
    } // Update stale interval if needed


    if (config.enabled !== prevConfig.enabled || config.staleTime !== prevConfig.staleTime) {
      this.updateStaleTimeout();
    } // Update refetch interval if needed


    if (config.enabled !== prevConfig.enabled || config.refetchInterval !== prevConfig.refetchInterval || config.refetchIntervalInBackground !== prevConfig.refetchIntervalInBackground) {
      this.updateRefetchInterval();
    }
  };

  _proto.isStale = function isStale() {
    return this.currentResult.isStale;
  };

  _proto.getCurrentQuery = function getCurrentQuery() {
    return this.currentQuery;
  };

  _proto.getCurrentResult = function getCurrentResult() {
    return this.currentResult;
  };

  _proto.clear = function clear() {
    return this.currentQuery.clear();
  };

  _proto.refetch = function refetch(options) {
    try {
      var _this2 = this;

      return _this2.currentQuery.refetch(options, _this2.config);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {
    try {
      var _this4 = this;

      return _this4.currentQuery.fetchMore(fetchMoreVariable, options, _this4.config);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.fetch = function fetch() {
    var _this5 = this;

    return _await(_catch(function () {
      return _await(_this5.currentQuery.fetch(undefined, _this5.config));
    }, _empty));
  };

  _proto.optionalFetch = function optionalFetch() {
    if (this.config.enabled && // Don't auto refetch if disabled
    !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched
    this.currentResult.isStale && ( // Only refetch if stale
    this.config.refetchOnMount || this.currentQuery.observers.length === 1)) {
      this.fetch();
    }
  };

  _proto.updateIsStale = function updateIsStale() {
    var isStale = this.currentQuery.isStaleByTime(this.config.staleTime);

    if (isStale !== this.currentResult.isStale) {
      this.updateResult();
      this.notify();
    }
  };

  _proto.notify = function notify() {
    var _this$updateListener;

    (_this$updateListener = this.updateListener) == null ? void 0 : _this$updateListener.call(this, this.currentResult);
  };

  _proto.updateStaleTimeout = function updateStaleTimeout() {
    var _this6 = this;

    if (isServer) {
      return;
    }

    this.clearStaleTimeout();
    var staleTime = this.config.staleTime || 0;
    var _this$currentResult = this.currentResult,
        isStale = _this$currentResult.isStale,
        updatedAt = _this$currentResult.updatedAt;

    if (isStale || staleTime === Infinity) {
      return;
    }

    var timeElapsed = Date.now() - updatedAt;
    var timeUntilStale = staleTime - timeElapsed;
    var timeout = Math.max(timeUntilStale, 0);
    this.staleTimeoutId = setTimeout(function () {
      _this6.updateIsStale();
    }, timeout);
  };

  _proto.updateRefetchInterval = function updateRefetchInterval() {
    var _this7 = this;

    if (isServer) {
      return;
    }

    this.clearRefetchInterval();

    if (!this.config.enabled || !this.config.refetchInterval || this.config.refetchInterval < 0 || this.config.refetchInterval === Infinity) {
      return;
    }

    this.refetchIntervalId = setInterval(function () {
      if (_this7.config.refetchIntervalInBackground || isDocumentVisible()) {
        _this7.fetch();
      }
    }, this.config.refetchInterval);
  };

  _proto.updateTimers = function updateTimers() {
    this.updateStaleTimeout();
    this.updateRefetchInterval();
  };

  _proto.clearTimers = function clearTimers() {
    this.clearStaleTimeout();
    this.clearRefetchInterval();
  };

  _proto.clearStaleTimeout = function clearStaleTimeout() {
    if (this.staleTimeoutId) {
      clearInterval(this.staleTimeoutId);
      this.staleTimeoutId = undefined;
    }
  };

  _proto.clearRefetchInterval = function clearRefetchInterval() {
    if (this.refetchIntervalId) {
      clearInterval(this.refetchIntervalId);
      this.refetchIntervalId = undefined;
    }
  };

  _proto.updateResult = function updateResult() {
    var currentQuery = this.currentQuery,
        currentResult = this.currentResult,
        previousQueryResult = this.previousQueryResult,
        config = this.config;
    var state = currentQuery.state;
    var data = state.data,
        status = state.status,
        updatedAt = state.updatedAt;
    var isPreviousData = false; // Keep previous data if needed

    if (config.keepPreviousData && (state.isIdle || state.isLoading) && (previousQueryResult == null ? void 0 : previousQueryResult.isSuccess)) {
      data = previousQueryResult.data;
      updatedAt = previousQueryResult.updatedAt;
      status = previousQueryResult.status;
      isPreviousData = true;
    }

    var isStale = false; // When the query has not been fetched yet and this is the initial render,
    // determine the staleness based on the initialStale or existence of initial data.

    if (!currentResult && !state.isFetched) {
      if (typeof config.initialStale === 'function') {
        isStale = config.initialStale();
      } else if (typeof config.initialStale === 'boolean') {
        isStale = config.initialStale;
      } else {
        isStale = typeof state.data === 'undefined';
      }
    } else {
      isStale = currentQuery.isStaleByTime(config.staleTime);
    }

    this.currentResult = _extends({}, getStatusProps(status), {
      canFetchMore: state.canFetchMore,
      clear: this.clear,
      data: data,
      error: state.error,
      failureCount: state.failureCount,
      fetchMore: this.fetchMore,
      isFetched: state.isFetched,
      isFetchedAfterMount: state.fetchedCount > this.initialFetchedCount,
      isFetching: state.isFetching,
      isFetchingMore: state.isFetchingMore,
      isPreviousData: isPreviousData,
      isStale: isStale,
      refetch: this.refetch,
      updatedAt: updatedAt
    });
  };

  _proto.updateQuery = function updateQuery() {
    var prevQuery = this.currentQuery; // Remove the initial data when there is an existing query
    // because this data should not be used for a new query

    var config = this.config.keepPreviousData && prevQuery ? _extends({}, this.config, {
      initialData: undefined
    }) : this.config;
    var newQuery = this.queryCache.buildQuery(config.queryKey, config);

    if (newQuery === prevQuery) {
      return false;
    }

    this.previousQueryResult = this.currentResult;
    this.currentQuery = newQuery;
    this.initialFetchedCount = newQuery.state.fetchedCount;
    this.updateResult();

    if (this.started) {
      prevQuery == null ? void 0 : prevQuery.unsubscribeObserver(this);
      this.currentQuery.subscribeObserver(this);
    }

    return true;
  };

  _proto.onQueryUpdate = function onQueryUpdate(action) {
    // Store current result and get new result
    var prevResult = this.currentResult;
    this.updateResult();
    var currentResult = this.currentResult,
        config = this.config; // We need to check the action because the state could have
    // transitioned from success to success in case of `setQueryData`.

    if (action.type === 'Success' && currentResult.isSuccess) {
      config.onSuccess == null ? void 0 : config.onSuccess(currentResult.data);
      config.onSettled == null ? void 0 : config.onSettled(currentResult.data, null);
      this.updateTimers();
    } else if (action.type === 'Error' && currentResult.isError) {
      config.onError == null ? void 0 : config.onError(currentResult.error);
      config.onSettled == null ? void 0 : config.onSettled(undefined, currentResult.error);
      this.updateTimers();
    }

    if ( // Always notify on data or error change
    currentResult.data !== prevResult.data || currentResult.error !== prevResult.error || // Maybe notify on other changes
    config.notifyOnStatusChange) {
      this.notify();
    }
  };

  return QueryObserver;
}();

function _await$1(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

function _catch$1(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function _invoke(body, then) {
  var result = body();

  if (result && result.then) {
    return result.then(then);
  }

  return then(result);
}

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

function _empty$1() {}

function _awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(_empty$1) : Promise.resolve();
  }
}

var ActionType;

(function (ActionType) {
  ActionType["Failed"] = "Failed";
  ActionType["Fetch"] = "Fetch";
  ActionType["Success"] = "Success";
  ActionType["Error"] = "Error";
})(ActionType || (ActionType = {}));

// CLASS
var Query = /*#__PURE__*/function () {
  function Query(init) {
    this.config = init.config;
    this.queryCache = init.queryCache;
    this.queryKey = init.queryKey;
    this.queryHash = init.queryHash;
    this.notifyGlobalListeners = init.notifyGlobalListeners;
    this.observers = [];
    this.state = getDefaultState(init.config);
    this.cacheTime = init.config.cacheTime;
    this.scheduleGc();
  }

  var _proto = Query.prototype;

  _proto.updateConfig = function updateConfig(config) {
    this.config = config;
    this.cacheTime = Math.max(this.cacheTime, config.cacheTime || 0);
  };

  _proto.dispatch = function dispatch(action) {
    this.state = queryReducer(this.state, action);
    this.observers.forEach(function (observer) {
      observer.onQueryUpdate(action);
    });
    this.notifyGlobalListeners(this);
  };

  _proto.scheduleGc = function scheduleGc() {
    var _this = this;

    if (isServer) {
      return;
    }

    this.clearGcTimeout();

    if (this.cacheTime === Infinity || this.observers.length > 0) {
      return;
    }

    this.gcTimeout = setTimeout(function () {
      _this.clear();
    }, this.cacheTime);
  };

  _proto.cancel = function cancel() {
    var _this$cancelFetch;

    (_this$cancelFetch = this.cancelFetch) == null ? void 0 : _this$cancelFetch.call(this);
  };

  _proto.continue = function _continue() {
    var _this$continueFetch;

    (_this$continueFetch = this.continueFetch) == null ? void 0 : _this$continueFetch.call(this);
  };

  _proto.clearTimersObservers = function clearTimersObservers() {
    this.observers.forEach(function (observer) {
      observer.clearTimers();
    });
  };

  _proto.clearGcTimeout = function clearGcTimeout() {
    if (this.gcTimeout) {
      clearTimeout(this.gcTimeout);
      this.gcTimeout = undefined;
    }
  };

  _proto.setData = function setData(updater) {
    var _this$config$isDataEq, _this$config;

    var prevData = this.state.data; // Get the new data

    var data = functionalUpdate(updater, prevData); // Structurally share data between prev and new data if needed

    if (this.config.structuralSharing) {
      data = replaceEqualDeep(prevData, data);
    } // Use prev data if an isDataEqual function is defined and returns `true`


    if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {
      data = prevData;
    } // Try to determine if more data can be fetched


    var canFetchMore = hasMorePages(this.config, data); // Set data and mark it as cached

    this.dispatch({
      type: ActionType.Success,
      data: data,
      canFetchMore: canFetchMore
    });
  };

  _proto.clear = function clear() {
    this.queryCache.removeQuery(this);
  };

  _proto.destroy = function destroy() {
    this.clearGcTimeout();
    this.clearTimersObservers();
    this.cancel();
  };

  _proto.isEnabled = function isEnabled() {
    return this.observers.some(function (observer) {
      return observer.config.enabled;
    });
  };

  _proto.isStale = function isStale() {
    return this.observers.some(function (observer) {
      return observer.isStale();
    });
  };

  _proto.isStaleByTime = function isStaleByTime(staleTime) {
    if (staleTime === void 0) {
      staleTime = 0;
    }

    return !this.state.isSuccess || this.state.updatedAt + staleTime <= Date.now();
  };

  _proto.onInteraction = function onInteraction(type) {
    // Execute the first observer which is enabled,
    // stale and wants to refetch on this interaction.
    var observer = this.observers.find(function (observer) {
      return observer.isStale() && observer.config.enabled && (observer.config.refetchOnWindowFocus && type === 'focus' || observer.config.refetchOnReconnect && type === 'online');
    });

    if (observer) {
      observer.fetch().catch(noop);
    } // Continue any paused fetch


    this.continue();
  };

  _proto.subscribe = function subscribe(listener) {
    var observer = new QueryObserver(_extends({
      queryCache: this.queryCache,
      queryKey: this.queryKey
    }, this.config));
    observer.subscribe(listener);
    return observer;
  };

  _proto.subscribeObserver = function subscribeObserver(observer) {
    this.observers.push(observer); // Stop the query from being garbage collected

    this.clearGcTimeout();
  };

  _proto.unsubscribeObserver = function unsubscribeObserver(observer) {
    this.observers = this.observers.filter(function (x) {
      return x !== observer;
    });

    if (!this.observers.length) {
      // If the transport layer does not support cancellation
      // we'll let the query continue so the result can be cached
      if (this.isTransportCancelable) {
        this.cancel();
      }
    }

    this.scheduleGc();
  };

  _proto.refetch = function refetch(options, config) {
    try {
      var _this3 = this;

      return _catch$1(function () {
        return _await$1(_this3.fetch(undefined, config));
      }, function (error) {
        if ((options == null ? void 0 : options.throwOnError) === true) {
          throw error;
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.fetchMore = function fetchMore(fetchMoreVariable, options, config) {
    try {
      var _this5 = this;

      return _this5.fetch({
        fetchMore: {
          fetchMoreVariable: fetchMoreVariable,
          previous: (options == null ? void 0 : options.previous) || false
        }
      }, config);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.fetch = function fetch(options, config) {
    try {
      var _this7 = this;

      // If we are already fetching, return current promise
      if (_this7.promise) {
        return _this7.promise;
      } // Update config if passed, otherwise the config from the last execution is used


      if (config) {
        _this7.updateConfig(config);
      }

      config = _this7.config; // Check if there is a query function

      if (typeof config.queryFn !== 'function') {
        return;
      } // Get the query function params


      var filter = config.queryFnParamsFilter;
      var params = filter ? filter(_this7.queryKey) : _this7.queryKey;
      _this7.promise = _async(function () {
        return _catch$1(function () {
          var data;
          return _invoke(function () {
            if (config.infinite) {
              return _await$1(_this7.startInfiniteFetch(config, params, options), function (_this7$startInfiniteF) {
                data = _this7$startInfiniteF;
              });
            } else {
              return _await$1(_this7.startFetch(config, params, options), function (_this7$startFetch) {
                data = _this7$startFetch;
              });
            }
          }, function () {
            // Set success state
            _this7.setData(data); // Cleanup


            delete _this7.promise; // Return data

            return data;
          });
        }, function (error) {
          // Set error state
          _this7.dispatch({
            type: ActionType.Error,
            error: error
          }); // Log error


          if (!isCancelledError(error)) {
            Console.error(error);
          } // Cleanup


          delete _this7.promise; // Propagate error

          throw error;
        });
      })();
      return _this7.promise;
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.startFetch = function startFetch(config, params, _options) {
    try {
      var _this9 = this;

      // Create function to fetch the data
      var fetchData = function fetchData() {
        return config.queryFn.apply(void 0, params);
      }; // Set to fetching state if not already in it


      if (!_this9.state.isFetching) {
        _this9.dispatch({
          type: ActionType.Fetch
        });
      } // Try to fetch the data


      return _this9.tryFetchData(config, fetchData);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.startInfiniteFetch = function startInfiniteFetch(config, params, options) {
    try {
      var _this11 = this;

      var fetchMore = options == null ? void 0 : options.fetchMore;

      var _ref = fetchMore || {},
          previous = _ref.previous,
          fetchMoreVariable = _ref.fetchMoreVariable;

      var isFetchingMore = fetchMore ? previous ? 'previous' : 'next' : false;
      var prevPages = _this11.state.data || []; // Create function to fetch a page

      var fetchPage = _async(function (pages, prepend, cursor) {
        var lastPage = getLastPage(pages, prepend);

        if (typeof cursor === 'undefined' && typeof lastPage !== 'undefined' && config.getFetchMore) {
          cursor = config.getFetchMore(lastPage, pages);
        }

        return _await$1(config.queryFn.apply(void 0, params.concat([cursor])), function (page) {
          return prepend ? [page].concat(pages) : [].concat(pages, [page]);
        });
      }); // Create function to fetch the data


      var fetchData = function fetchData() {
        if (isFetchingMore) {
          return fetchPage(prevPages, previous, fetchMoreVariable);
        } else if (!prevPages.length) {
          return fetchPage([]);
        } else {
          var promise = fetchPage([]);

          for (var i = 1; i < prevPages.length; i++) {
            promise = promise.then(fetchPage);
          }

          return promise;
        }
      }; // Set to fetching state if not already in it


      if (!_this11.state.isFetching) {
        _this11.dispatch({
          type: ActionType.Fetch,
          isFetchingMore: isFetchingMore
        });
      } // Try to get the data


      return _this11.tryFetchData(config, fetchData);
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.tryFetchData = function tryFetchData(config, fn) {
    try {
      var _this13 = this;

      return new Promise(function (outerResolve, outerReject) {
        var resolved = false;
        var continueLoop;
        var cancelTransport;

        var done = function done() {
          resolved = true;
          delete _this13.cancelFetch;
          delete _this13.continueFetch;
          delete _this13.isTransportCancelable; // End loop if currently paused

          continueLoop == null ? void 0 : continueLoop();
        };

        var resolve = function resolve(value) {
          done();
          outerResolve(value);
        };

        var reject = function reject(value) {
          done();
          outerReject(value);
        }; // Create callback to cancel this fetch


        _this13.cancelFetch = function () {
          reject(new CancelledError());

          try {
            cancelTransport == null ? void 0 : cancelTransport();
          } catch (_unused) {}
        }; // Create callback to continue this fetch


        _this13.continueFetch = function () {
          continueLoop == null ? void 0 : continueLoop();
        }; // Create loop function


        var run = _async(function () {
          return _catch$1(function () {
            // Execute query
            var promiseOrValue = fn(); // Check if the transport layer support cancellation

            if (isCancelable(promiseOrValue)) {
              cancelTransport = function cancelTransport() {
                promiseOrValue.cancel();
              };

              _this13.isTransportCancelable = true;
            } // Await data


            return _await$1(promiseOrValue, function (_promiseOrValue) {
              resolve(_promiseOrValue);
            });
          }, function (error) {
            // Stop if the fetch is already resolved
            if (resolved) {
              return;
            } // Do we need to retry the request?


            var failureCount = _this13.state.failureCount;
            var retry = config.retry,
                retryDelay = config.retryDelay;
            var shouldRetry = retry === true || failureCount < retry || typeof retry === 'function' && retry(failureCount, error);

            if (!shouldRetry) {
              // We are done if the query does not need to be retried
              reject(error);
              return;
            } // Increase the failureCount


            _this13.dispatch({
              type: ActionType.Failed
            }); // Delay


            return _await$1(sleep(functionalUpdate(retryDelay, failureCount) || 0), function () {
              // Pause retry if the document is not visible or when the device is offline
              return _invoke(function () {
                if (!isDocumentVisible() || !isOnline()) {
                  return _awaitIgnored(new Promise(function (continueResolve) {
                    continueLoop = continueResolve;
                  }));
                }
              }, function () {
                if (!resolved) {
                  run();
                }
              }); // Try again if not resolved yet
            });
          });
        }); // Start loop


        run();
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return Query;
}();

function getLastPage(pages, previous) {
  return previous ? pages[0] : pages[pages.length - 1];
}

function hasMorePages(config, pages, previous) {
  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {
    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages));
  }
}

function getDefaultState(config) {
  var initialData = typeof config.initialData === 'function' ? config.initialData() : config.initialData;
  var hasInitialData = typeof initialData !== 'undefined';
  var initialStatus = hasInitialData ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;
  return _extends({}, getStatusProps(initialStatus), {
    error: null,
    isFetched: false,
    isFetching: initialStatus === QueryStatus.Loading,
    isFetchingMore: false,
    failureCount: 0,
    fetchedCount: 0,
    data: initialData,
    updatedAt: Date.now(),
    canFetchMore: hasMorePages(config, initialData)
  });
}

function queryReducer(state, action) {
  switch (action.type) {
    case ActionType.Failed:
      return _extends({}, state, {
        failureCount: state.failureCount + 1
      });

    case ActionType.Fetch:
      var status = typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading;
      return _extends({}, state, getStatusProps(status), {
        isFetching: true,
        isFetchingMore: action.isFetchingMore || false,
        failureCount: 0
      });

    case ActionType.Success:
      return _extends({}, state, getStatusProps(QueryStatus.Success), {
        data: action.data,
        error: null,
        fetchedCount: state.fetchedCount + 1,
        isFetched: true,
        isFetching: false,
        isFetchingMore: false,
        canFetchMore: action.canFetchMore,
        updatedAt: Date.now(),
        failureCount: 0
      });

    case ActionType.Error:
      return _extends({}, state, getStatusProps(QueryStatus.Error), {
        error: action.error,
        fetchedCount: state.fetchedCount + 1,
        isFetched: true,
        isFetching: false,
        isFetchingMore: false,
        failureCount: state.failureCount + 1,
        throwInErrorBoundary: true
      });

    default:
      return state;
  }
}

// CLASS
function _empty$2() {}

function _awaitIgnored$1(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(_empty$2) : Promise.resolve();
  }
}

function _catch$2(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function _invoke$1(body, then) {
  var result = body();

  if (result && result.then) {
    return result.then(then);
  }

  return then(result);
}

var QueryCache = /*#__PURE__*/function () {
  function QueryCache(config) {
    this.config = config || {}; // A frozen cache does not add new queries to the cache

    this.globalListeners = [];
    this.queries = {};
    this.queriesArray = [];
    this.isFetching = 0;
  }

  var _proto = QueryCache.prototype;

  _proto.notifyGlobalListeners = function notifyGlobalListeners(query) {
    var _this = this;

    this.isFetching = this.getQueries().reduce(function (acc, query) {
      return query.state.isFetching ? acc + 1 : acc;
    }, 0);
    this.globalListeners.forEach(function (listener) {
      listener(_this, query);
    });
  };

  _proto.getDefaultConfig = function getDefaultConfig() {
    return this.config.defaultConfig;
  };

  _proto.getDefaultedQueryConfig = function getDefaultedQueryConfig$1(config) {
    return getDefaultedQueryConfig(this.getDefaultConfig(), undefined, config, {
      queryCache: this
    });
  };

  _proto.subscribe = function subscribe(listener) {
    var _this2 = this;

    this.globalListeners.push(listener);
    return function () {
      _this2.globalListeners = _this2.globalListeners.filter(function (x) {
        return x !== listener;
      });
    };
  };

  _proto.clear = function clear(options) {
    this.removeQueries();

    if (options == null ? void 0 : options.notify) {
      this.notifyGlobalListeners();
    }
  };

  _proto.getQueries = function getQueries(predicate, options) {
    if (predicate === true || typeof predicate === 'undefined') {
      return this.queriesArray;
    }

    var predicateFn;

    if (typeof predicate === 'function') {
      predicateFn = predicate;
    } else {
      var _config = this.getDefaultedQueryConfig();

      var _ref = _config.queryKeySerializerFn(predicate),
          queryHash = _ref[0],
          _queryKey = _ref[1];

      predicateFn = function predicateFn(d) {
        return (options == null ? void 0 : options.exact) ? d.queryHash === queryHash : deepIncludes(d.queryKey, _queryKey);
      };
    }

    return this.queriesArray.filter(predicateFn);
  };

  _proto.getQuery = function getQuery(predicate) {
    return this.getQueries(predicate, {
      exact: true
    })[0];
  };

  _proto.getQueryData = function getQueryData(predicate) {
    var _this$getQuery;

    return (_this$getQuery = this.getQuery(predicate)) == null ? void 0 : _this$getQuery.state.data;
  };

  _proto.removeQuery = function removeQuery(query) {
    if (this.queries[query.queryHash]) {
      query.destroy();
      delete this.queries[query.queryHash];
      this.queriesArray = this.queriesArray.filter(function (x) {
        return x !== query;
      });
      this.notifyGlobalListeners(query);
    }
  };

  _proto.removeQueries = function removeQueries(predicate, options) {
    var _this3 = this;

    this.getQueries(predicate, options).forEach(function (query) {
      _this3.removeQuery(query);
    });
  };

  _proto.cancelQueries = function cancelQueries(predicate, options) {
    this.getQueries(predicate, options).forEach(function (query) {
      query.cancel();
    });
  };

  _proto.invalidateQueries = function invalidateQueries(predicate, options) {
    try {
      var _this5 = this;

      var _ref2 = options || {},
          _ref2$refetchActive = _ref2.refetchActive,
          refetchActive = _ref2$refetchActive === void 0 ? true : _ref2$refetchActive,
          _ref2$refetchInactive = _ref2.refetchInactive,
          refetchInactive = _ref2$refetchInactive === void 0 ? false : _ref2$refetchInactive,
          throwOnError = _ref2.throwOnError;

      return _catch$2(function () {
        return _awaitIgnored$1(Promise.all(_this5.getQueries(predicate, options).map(function (query) {
          var enabled = query.isEnabled();

          if (enabled && refetchActive || !enabled && refetchInactive) {
            return query.fetch();
          }

          return undefined;
        })));
      }, function (err) {
        if (throwOnError) {
          throw err;
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.resetErrorBoundaries = function resetErrorBoundaries() {
    this.getQueries().forEach(function (query) {
      query.state.throwInErrorBoundary = false;
    });
  };

  _proto.buildQuery = function buildQuery(userQueryKey, queryConfig) {
    var _this6 = this;

    var config = this.getDefaultedQueryConfig(queryConfig);

    var _ref3 = config.queryKeySerializerFn(userQueryKey),
        queryHash = _ref3[0],
        queryKey = _ref3[1];

    if (this.queries[queryHash]) {
      return this.queries[queryHash];
    }

    var query = new Query({
      queryCache: this,
      queryKey: queryKey,
      queryHash: queryHash,
      config: config,
      notifyGlobalListeners: function notifyGlobalListeners(query) {
        _this6.notifyGlobalListeners(query);
      }
    });

    if (!this.config.frozen) {
      this.queries[queryHash] = query;
      this.queriesArray.push(query);
      this.notifyGlobalListeners(query);
    }

    return query;
  } // Parameter syntax with optional prefetch options
  ;

  // Implementation
  _proto.prefetchQuery = function prefetchQuery() {
    try {
      var _this8 = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (isObject(args[1]) && (args[1].hasOwnProperty('throwOnError') || args[1].hasOwnProperty('force'))) {
        args[3] = args[1];
        args[1] = undefined;
        args[2] = undefined;
      }

      var _getQueryArgs = getQueryArgs(args),
          _queryKey2 = _getQueryArgs[0],
          _config2 = _getQueryArgs[1],
          _options = _getQueryArgs[2]; // https://github.com/tannerlinsley/react-query/issues/652


      var configWithoutRetry = _this8.getDefaultedQueryConfig(_extends({
        retry: false
      }, _config2));

      var _query;

      return _catch$2(function () {
        _query = _this8.buildQuery(_queryKey2, configWithoutRetry);
        return _invoke$1(function () {
          if ((_options == null ? void 0 : _options.force) || _query.isStaleByTime(_config2.staleTime)) {
            return _awaitIgnored$1(_query.fetch(undefined, configWithoutRetry));
          }
        }, function () {
          return _query.state.data;
        });
      }, function (error) {
        if (_options == null ? void 0 : _options.throwOnError) {
          throw error;
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.setQueryData = function setQueryData(queryKey, updater, config) {
    var query = this.getQuery(queryKey);

    if (query) {
      query.setData(updater);
      return;
    }

    this.buildQuery(queryKey, _extends({
      initialStale: typeof (config == null ? void 0 : config.staleTime) === 'undefined',
      initialData: functionalUpdate(updater, undefined)
    }, config));
  };

  return QueryCache;
}();
var defaultQueryCache = makeQueryCache({
  frozen: isServer
});
var queryCaches = [defaultQueryCache];
function makeQueryCache(config) {
  return new QueryCache(config);
}
function onVisibilityOrOnlineChange(type) {
  if (isDocumentVisible() && isOnline()) {
    queryCaches.forEach(function (queryCache) {
      queryCache.getQueries().forEach(function (query) {
        query.onInteraction(type);
      });
    });
  }
}

var setFocusHandler = createSetHandler(function () {
  return onVisibilityOrOnlineChange('focus');
});
setFocusHandler(function (handleFocus) {
  var _window;

  if (isServer || !((_window = window) == null ? void 0 : _window.addEventListener)) {
    return;
  } // Listen to visibillitychange and focus


  window.addEventListener('visibilitychange', handleFocus, false);
  window.addEventListener('focus', handleFocus, false);
  return function () {
    // Be sure to unsubscribe if a new handler is set
    window.removeEventListener('visibilitychange', handleFocus);
    window.removeEventListener('focus', handleFocus);
  };
});

var setOnlineHandler = createSetHandler(function () {
  return onVisibilityOrOnlineChange('online');
});
setOnlineHandler(function (handleOnline) {
  var _window;

  if (isServer || !((_window = window) == null ? void 0 : _window.addEventListener)) {
    return;
  } // Listen to online


  window.addEventListener('online', handleOnline, false);
  return function () {
    // Be sure to unsubscribe if a new handler is set
    window.removeEventListener('online', handleOnline);
  };
});

var queryCacheContext = React.createContext(defaultQueryCache);
var useQueryCache = function useQueryCache() {
  return React.useContext(queryCacheContext);
};
var ReactQueryCacheProvider = function ReactQueryCacheProvider(_ref) {
  var queryCache = _ref.queryCache,
      children = _ref.children;
  var resolvedQueryCache = React.useMemo(function () {
    return queryCache || makeQueryCache();
  }, [queryCache]);
  React.useEffect(function () {
    queryCaches.push(resolvedQueryCache);
    return function () {
      // remove the cache from the active list
      var i = queryCaches.indexOf(resolvedQueryCache);

      if (i > -1) {
        queryCaches.splice(i, 1);
      } // if the resolvedQueryCache was created by us, we need to tear it down


      if (queryCache == null) {
        resolvedQueryCache.clear({
          notify: false
        });
      }
    };
  }, [resolvedQueryCache, queryCache]);
  return /*#__PURE__*/React.createElement(queryCacheContext.Provider, {
    value: resolvedQueryCache
  }, children);
};

var configContext = React.createContext(undefined);
function useContextConfig() {
  return React.useContext(configContext);
}
var ReactQueryConfigProvider = function ReactQueryConfigProvider(_ref) {
  var config = _ref.config,
      children = _ref.children;
  var parentConfig = useContextConfig();
  var mergedConfig = React.useMemo(function () {
    return parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config;
  }, [config, parentConfig]);
  return /*#__PURE__*/React.createElement(configContext.Provider, {
    value: mergedConfig
  }, children);
};

function useGetLatest(obj) {
  var ref = React.useRef(obj);
  ref.current = obj;
  return React.useCallback(function () {
    return ref.current;
  }, []);
}

function useIsMounted() {
  var mountedRef = React.useRef(false);
  var isMounted = React.useCallback(function () {
    return mountedRef.current;
  }, []);
  React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {
    mountedRef.current = true;
    return function () {
      mountedRef.current = false;
    };
  }, []);
  return isMounted;
}

function useMountedCallback(callback) {
  var isMounted = useIsMounted();
  return React.useCallback(function () {
    if (isMounted()) {
      return callback.apply(void 0, arguments);
    }
  }, [callback, isMounted]);
}
/**
 * This hook is a safe useState version which schedules state updates in microtasks
 * to prevent updating a component state while React is rendering different components
 * or when the component is not mounted anymore.
 */

function useSafeState(initialState) {
  var isMounted = useIsMounted();

  var _React$useState = React.useState(initialState),
      state = _React$useState[0],
      setState = _React$useState[1];

  var safeSetState = React.useCallback(function (value) {
    scheduleMicrotask(function () {
      if (isMounted()) {
        setState(value);
      }
    });
  }, [isMounted]);
  return [state, safeSetState];
}
function useRerenderer() {
  var _useSafeState = useSafeState({}),
      setState = _useSafeState[1];

  return React.useCallback(function () {
    return setState({});
  }, [setState]);
}
/**
 * Schedules a microtask.
 * This can be useful to schedule state updates after rendering.
 */

function scheduleMicrotask(callback) {
  Promise.resolve().then(callback).catch(function (error) {
    return setTimeout(function () {
      throw error;
    });
  });
}

function useIsFetching() {
  var queryCache = useQueryCache();

  var _useSafeState = useSafeState(queryCache.isFetching),
      isFetching = _useSafeState[0],
      setIsFetching = _useSafeState[1];

  React.useEffect(function () {
    return queryCache.subscribe(function () {
      setIsFetching(queryCache.isFetching);
    });
  }, [queryCache, setIsFetching]);
  return isFetching;
}

function useDefaultedMutationConfig(config) {
  var contextConfig = useContextConfig();
  var contextQueryCache = useQueryCache();
  var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;
  var queryCacheConfig = queryCache.getDefaultConfig();
  return getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, {
    queryCache: queryCache
  });
}

function _await$2(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

var ActionType$1;

function _catch$3(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }

  if (result && result.then) {
    return result.then(void 0, recover);
  }

  return result;
}

function _async$1(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

(function (ActionType) {
  ActionType["Reset"] = "Reset";
  ActionType["Loading"] = "Loading";
  ActionType["Resolve"] = "Resolve";
  ActionType["Reject"] = "Reject";
})(ActionType$1 || (ActionType$1 = {}));

// HOOK
var getDefaultState$1 = function getDefaultState() {
  return _extends({}, getStatusProps(QueryStatus.Idle), {
    data: undefined,
    error: null
  });
};

function mutationReducer(state, action) {
  switch (action.type) {
    case ActionType$1.Reset:
      return getDefaultState$1();

    case ActionType$1.Loading:
      return _extends({}, getStatusProps(QueryStatus.Loading), {
        data: undefined,
        error: null
      });

    case ActionType$1.Resolve:
      return _extends({}, getStatusProps(QueryStatus.Success), {
        data: action.data,
        error: null
      });

    case ActionType$1.Reject:
      return _extends({}, getStatusProps(QueryStatus.Error), {
        data: undefined,
        error: action.error
      });

    default:
      return state;
  }
}

function useMutation(mutationFn, config) {
  if (config === void 0) {
    config = {};
  }

  config = useDefaultedMutationConfig(config);
  var getConfig = useGetLatest(config);

  var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState$1),
      state = _React$useReducer[0],
      unsafeDispatch = _React$useReducer[1];

  var dispatch = useMountedCallback(unsafeDispatch);
  var getMutationFn = useGetLatest(mutationFn);
  var latestMutationRef = React.useRef();
  var mutate = React.useCallback(_async$1(function (variables, mutateConfig) {
    if (mutateConfig === void 0) {
      mutateConfig = {};
    }

    var config = getConfig();
    var mutationId = uid();
    latestMutationRef.current = mutationId;

    var isLatest = function isLatest() {
      return latestMutationRef.current === mutationId;
    };

    var snapshotValue;
    return _catch$3(function () {
      dispatch({
        type: ActionType$1.Loading
      });
      return _await$2(config.onMutate == null ? void 0 : config.onMutate(variables), function (_config$onMutate) {
        snapshotValue = _config$onMutate;
        return _await$2(getMutationFn()(variables), function (data) {
          if (isLatest()) {
            dispatch({
              type: ActionType$1.Resolve,
              data: data
            });
          }

          return _await$2(config.onSuccess == null ? void 0 : config.onSuccess(data, variables), function () {
            return _await$2(mutateConfig.onSuccess == null ? void 0 : mutateConfig.onSuccess(data, variables), function () {
              return _await$2(config.onSettled == null ? void 0 : config.onSettled(data, null, variables), function () {
                return _await$2(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(data, null, variables), function () {
                  return data;
                });
              });
            });
          });
        });
      });
    }, function (error) {
      Console.error(error);
      return _await$2(config.onError == null ? void 0 : config.onError(error, variables, snapshotValue), function () {
        return _await$2(mutateConfig.onError == null ? void 0 : mutateConfig.onError(error, variables, snapshotValue), function () {
          return _await$2(config.onSettled == null ? void 0 : config.onSettled(undefined, error, variables, snapshotValue), function () {
            return _await$2(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(undefined, error, variables, snapshotValue), function () {
              var _mutateConfig$throwOn;

              if (isLatest()) {
                dispatch({
                  type: ActionType$1.Reject,
                  error: error
                });
              }

              if ((_mutateConfig$throwOn = mutateConfig.throwOnError) != null ? _mutateConfig$throwOn : config.throwOnError) {
                throw error;
              }
            });
          });
        });
      });
    });
  }), [dispatch, getConfig, getMutationFn]);
  var reset = React.useCallback(function () {
    dispatch({
      type: ActionType$1.Reset
    });
  }, [dispatch]);
  React.useEffect(function () {
    var _getConfig = getConfig(),
        suspense = _getConfig.suspense,
        useErrorBoundary = _getConfig.useErrorBoundary;

    if ((useErrorBoundary != null ? useErrorBoundary : suspense) && state.error) {
      throw state.error;
    }
  }, [getConfig, state.error]);
  return [mutate, _extends({}, state, {
    reset: reset
  })];
}

function useDefaultedQueryConfig(config) {
  var contextConfig = useContextConfig();
  var contextQueryCache = useQueryCache();
  var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;
  var queryCacheConfig = queryCache.getDefaultConfig();
  return getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, {
    queryCache: queryCache
  });
}

function useBaseQuery(config) {
  if (config === void 0) {
    config = {};
  }

  config = useDefaultedQueryConfig(config); // Make a rerender function

  var rerender = useRerenderer(); // Create query observer

  var observerRef = React.useRef();
  var firstRender = !observerRef.current;
  var observer = observerRef.current || new QueryObserver(config);
  observerRef.current = observer; // Subscribe to the observer

  React.useEffect(function () {
    return observer.subscribe(function () {
      rerender();
    });
  }, [observer, rerender]); // Update config

  if (!firstRender) {
    observer.updateConfig(config);
  }

  var result = observer.getCurrentResult(); // Handle suspense

  if (config.suspense || config.useErrorBoundary) {
    var query = observer.getCurrentQuery();

    if (result.isError && query.state.throwInErrorBoundary) {
      throw result.error;
    }

    if (config.enabled && config.suspense && !result.isSuccess) {
      var unsubscribe = observer.subscribe();
      throw observer.fetch().finally(unsubscribe);
    }
  }

  return result;
}

// Implementation
function useQuery() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var config = getQueryArgs(args)[1];
  return useBaseQuery(config);
}

// as the query key changes, we keep the results from the
// last query and use them as placeholder data in the next one
// We DON'T use it as initial data though. That's important
// TYPES

// Implementation
function usePaginatedQuery() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var config = getQueryArgs(args)[1];
  var result = useBaseQuery(_extends({
    keepPreviousData: true
  }, config));
  return _extends({}, result, {
    resolvedData: result.data,
    latestData: result.isPreviousData ? undefined : result.data
  });
}

// Implementation
function useInfiniteQuery() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var config = getQueryArgs(args)[1];
  return useBaseQuery(_extends({}, config, {
    infinite: true
  }));
}

export { CancelledError, QueryStatus, ReactQueryCacheProvider, ReactQueryConfigProvider, isCancelledError, isError, makeQueryCache, defaultQueryCache as queryCache, queryCaches, setConsole, setFocusHandler, setOnlineHandler, useInfiniteQuery, useIsFetching, useMutation, usePaginatedQuery, useQuery, useQueryCache };
//# sourceMappingURL=react-query.mjs.map
