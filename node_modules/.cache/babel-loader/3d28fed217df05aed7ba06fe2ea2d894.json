{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar QueryStatus;\n\n(function (QueryStatus) {\n  QueryStatus[\"Idle\"] = \"idle\";\n  QueryStatus[\"Loading\"] = \"loading\";\n  QueryStatus[\"Error\"] = \"error\";\n  QueryStatus[\"Success\"] = \"success\";\n})(QueryStatus || (QueryStatus = {}));\n\nvar CancelledError = function CancelledError() {}; // UTILS\n\n\nvar _uid = 0;\n\nvar uid = function uid() {\n  return _uid++;\n};\n\nvar isServer = typeof window === 'undefined';\n\nfunction noop() {\n  return void 0;\n}\n\nvar Console = console || {\n  error: noop,\n  warn: noop,\n  log: noop\n};\n\nfunction setConsole(c) {\n  Console = c;\n}\n\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\n\nfunction stableStringifyReplacer(_key, value) {\n  if (typeof value === 'function') {\n    throw new Error('Cannot stringify non JSON value');\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value).sort().reduce(function (result, key) {\n      result[key] = value[key];\n      return result;\n    }, {});\n  }\n\n  return value;\n}\n\nfunction stableStringify(value) {\n  return JSON.stringify(value, stableStringifyReplacer);\n}\n\nfunction deepIncludes(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(function (key) {\n      return !deepIncludes(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\nfunction isDocumentVisible() {\n  // document global can be unavailable in react native\n  if (typeof document === 'undefined') {\n    return true;\n  }\n\n  return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n}\n\nfunction isOnline() {\n  return navigator.onLine === undefined || navigator.onLine;\n}\n\nfunction getQueryArgs(args) {\n  var queryKey;\n  var queryFn;\n  var config;\n  var options;\n\n  if (isObject(args[0])) {\n    queryKey = args[0].queryKey;\n    queryFn = args[0].queryFn;\n    config = args[0].config;\n    options = args[1];\n  } else if (isObject(args[1])) {\n    queryKey = args[0];\n    config = args[1];\n    options = args[2];\n  } else {\n    queryKey = args[0];\n    queryFn = args[1];\n    config = args[2];\n    options = args[3];\n  }\n\n  config = config ? _extends({\n    queryKey: queryKey\n  }, config) : {\n    queryKey: queryKey\n  };\n\n  if (queryFn) {\n    config = _extends({}, config, {\n      queryFn: queryFn\n    });\n  }\n\n  return [queryKey, config, options];\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\n\nfunction replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  var array = Array.isArray(a) && Array.isArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    var aSize = array ? a.length : Object.keys(a).length;\n    var bItems = array ? b : Object.keys(b);\n    var bSize = bItems.length;\n    var copy = array ? [] : {};\n    var equalItems = 0;\n\n    for (var i = 0; i < bSize; i++) {\n      var key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n\nfunction isObject(a) {\n  return a && typeof a === 'object' && !Array.isArray(a);\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  var ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  var prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\n\nfunction isError(value) {\n  return value instanceof Error;\n}\n\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\n\nfunction sleep(timeout) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, timeout);\n  });\n}\n\nfunction getStatusProps(status) {\n  return {\n    status: status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle\n  };\n}\n\nfunction createSetHandler(fn) {\n  var removePreviousHandler;\n  return function (callback) {\n    // Unsub the old handler\n    if (removePreviousHandler) {\n      removePreviousHandler();\n    } // Sub the new handler\n\n\n    removePreviousHandler = callback(fn);\n  };\n} // CONFIG\n\n\nvar defaultQueryKeySerializerFn = function defaultQueryKeySerializerFn(queryKey) {\n  try {\n    var arrayQueryKey = Array.isArray(queryKey) ? queryKey : [queryKey];\n    var queryHash = stableStringify(arrayQueryKey);\n    arrayQueryKey = JSON.parse(queryHash);\n    return [queryHash, arrayQueryKey];\n  } catch (_unused) {\n    throw new Error('A valid query key is required!');\n  }\n};\n/**\n * Config merging strategy\n *\n * When using hooks the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the hook query cache.\n * 3. Combined defaults from any config providers in the tree.\n * 4. Query/mutation config provided to the hook.\n *\n * When using a query cache directly the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the query cache.\n * 3. Query/mutation config provided to the query cache method.\n */\n\n\nvar DEFAULT_STALE_TIME = 0;\nvar DEFAULT_CACHE_TIME = 5 * 60 * 1000;\nvar DEFAULT_CONFIG = {\n  queries: {\n    cacheTime: DEFAULT_CACHE_TIME,\n    enabled: true,\n    notifyOnStatusChange: true,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    refetchOnMount: true,\n    refetchOnReconnect: true,\n    refetchOnWindowFocus: true,\n    retry: 3,\n    retryDelay: function retryDelay(attemptIndex) {\n      return Math.min(1000 * Math.pow(2, attemptIndex), 30000);\n    },\n    staleTime: DEFAULT_STALE_TIME,\n    structuralSharing: true\n  }\n};\n\nfunction mergeReactQueryConfigs(a, b) {\n  return {\n    shared: _extends({}, a.shared, b.shared),\n    queries: _extends({}, a.queries, b.queries),\n    mutations: _extends({}, a.mutations, b.mutations)\n  };\n}\n\nfunction getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, configOverrides) {\n  return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.queries, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.queries, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.queries, config, configOverrides);\n}\n\nfunction getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, configOverrides) {\n  return _extends({}, DEFAULT_CONFIG.shared, DEFAULT_CONFIG.mutations, queryCacheConfig == null ? void 0 : queryCacheConfig.shared, queryCacheConfig == null ? void 0 : queryCacheConfig.mutations, contextConfig == null ? void 0 : contextConfig.shared, contextConfig == null ? void 0 : contextConfig.mutations, config, configOverrides);\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _empty() {}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nvar QueryObserver = /*#__PURE__*/function () {\n  function QueryObserver(config) {\n    this.config = config;\n    this.queryCache = config.queryCache;\n    this.initialFetchedCount = 0; // Bind exposed methods\n\n    this.clear = this.clear.bind(this);\n    this.refetch = this.refetch.bind(this);\n    this.fetchMore = this.fetchMore.bind(this); // Subscribe to the query\n\n    this.updateQuery();\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.subscribe = function subscribe(listener) {\n    this.started = true;\n    this.updateListener = listener;\n    this.currentQuery.subscribeObserver(this);\n\n    if (this.config.enabled && this.config.forceFetchOnMount) {\n      this.fetch();\n    } else {\n      this.optionalFetch();\n    }\n\n    this.updateTimers();\n    return this.unsubscribe.bind(this);\n  };\n\n  _proto.unsubscribe = function unsubscribe() {\n    this.started = false;\n    this.updateListener = undefined;\n    this.clearTimers();\n    this.currentQuery.unsubscribeObserver(this);\n  };\n\n  _proto.updateConfig = function updateConfig(config) {\n    var prevConfig = this.config;\n    this.config = config;\n    var updated = this.updateQuery(); // Take no further actions if the observer did not start yet\n\n    if (!this.started) {\n      return;\n    } // If we subscribed to a new query, optionally fetch and update refetch\n\n\n    if (updated) {\n      this.optionalFetch();\n      this.updateTimers();\n      return;\n    } // Optionally fetch if the query became enabled\n\n\n    if (config.enabled && !prevConfig.enabled) {\n      this.optionalFetch();\n    } // Update stale interval if needed\n\n\n    if (config.enabled !== prevConfig.enabled || config.staleTime !== prevConfig.staleTime) {\n      this.updateStaleTimeout();\n    } // Update refetch interval if needed\n\n\n    if (config.enabled !== prevConfig.enabled || config.refetchInterval !== prevConfig.refetchInterval || config.refetchIntervalInBackground !== prevConfig.refetchIntervalInBackground) {\n      this.updateRefetchInterval();\n    }\n  };\n\n  _proto.isStale = function isStale() {\n    return this.currentResult.isStale;\n  };\n\n  _proto.getCurrentQuery = function getCurrentQuery() {\n    return this.currentQuery;\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  };\n\n  _proto.clear = function clear() {\n    return this.currentQuery.clear();\n  };\n\n  _proto.refetch = function refetch(options) {\n    try {\n      var _this2 = this;\n\n      return _this2.currentQuery.refetch(options, _this2.config);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options) {\n    try {\n      var _this4 = this;\n\n      return _this4.currentQuery.fetchMore(fetchMoreVariable, options, _this4.config);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetch = function fetch() {\n    var _this5 = this;\n\n    return _await(_catch(function () {\n      return _await(_this5.currentQuery.fetch(undefined, _this5.config));\n    }, _empty));\n  };\n\n  _proto.optionalFetch = function optionalFetch() {\n    if (this.config.enabled && // Don't auto refetch if disabled\n    !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched\n    this.currentResult.isStale && ( // Only refetch if stale\n    this.config.refetchOnMount || this.currentQuery.observers.length === 1)) {\n      this.fetch();\n    }\n  };\n\n  _proto.updateIsStale = function updateIsStale() {\n    var isStale = this.currentQuery.isStaleByTime(this.config.staleTime);\n\n    if (isStale !== this.currentResult.isStale) {\n      this.updateResult();\n      this.notify();\n    }\n  };\n\n  _proto.notify = function notify() {\n    var _this$updateListener;\n\n    (_this$updateListener = this.updateListener) == null ? void 0 : _this$updateListener.call(this, this.currentResult);\n  };\n\n  _proto.updateStaleTimeout = function updateStaleTimeout() {\n    var _this6 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearStaleTimeout();\n    var staleTime = this.config.staleTime || 0;\n    var _this$currentResult = this.currentResult,\n        isStale = _this$currentResult.isStale,\n        updatedAt = _this$currentResult.updatedAt;\n\n    if (isStale || staleTime === Infinity) {\n      return;\n    }\n\n    var timeElapsed = Date.now() - updatedAt;\n    var timeUntilStale = staleTime - timeElapsed;\n    var timeout = Math.max(timeUntilStale, 0);\n    this.staleTimeoutId = setTimeout(function () {\n      _this6.updateIsStale();\n    }, timeout);\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval() {\n    var _this7 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearRefetchInterval();\n\n    if (!this.config.enabled || !this.config.refetchInterval || this.config.refetchInterval < 0 || this.config.refetchInterval === Infinity) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this7.config.refetchIntervalInBackground || isDocumentVisible()) {\n        _this7.fetch();\n      }\n    }, this.config.refetchInterval);\n  };\n\n  _proto.updateTimers = function updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval();\n  };\n\n  _proto.clearTimers = function clearTimers() {\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearInterval(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  };\n\n  _proto.updateResult = function updateResult() {\n    var currentQuery = this.currentQuery,\n        currentResult = this.currentResult,\n        previousQueryResult = this.previousQueryResult,\n        config = this.config;\n    var state = currentQuery.state;\n    var data = state.data,\n        status = state.status,\n        updatedAt = state.updatedAt;\n    var isPreviousData = false; // Keep previous data if needed\n\n    if (config.keepPreviousData && (state.isIdle || state.isLoading) && (previousQueryResult == null ? void 0 : previousQueryResult.isSuccess)) {\n      data = previousQueryResult.data;\n      updatedAt = previousQueryResult.updatedAt;\n      status = previousQueryResult.status;\n      isPreviousData = true;\n    }\n\n    var isStale = false; // When the query has not been fetched yet and this is the initial render,\n    // determine the staleness based on the initialStale or existence of initial data.\n\n    if (!currentResult && !state.isFetched) {\n      if (typeof config.initialStale === 'function') {\n        isStale = config.initialStale();\n      } else if (typeof config.initialStale === 'boolean') {\n        isStale = config.initialStale;\n      } else {\n        isStale = typeof state.data === 'undefined';\n      }\n    } else {\n      isStale = currentQuery.isStaleByTime(config.staleTime);\n    }\n\n    this.currentResult = _extends({}, getStatusProps(status), {\n      canFetchMore: state.canFetchMore,\n      clear: this.clear,\n      data: data,\n      error: state.error,\n      failureCount: state.failureCount,\n      fetchMore: this.fetchMore,\n      isFetched: state.isFetched,\n      isFetchedAfterMount: state.fetchedCount > this.initialFetchedCount,\n      isFetching: state.isFetching,\n      isFetchingMore: state.isFetchingMore,\n      isPreviousData: isPreviousData,\n      isStale: isStale,\n      refetch: this.refetch,\n      updatedAt: updatedAt\n    });\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var prevQuery = this.currentQuery; // Remove the initial data when there is an existing query\n    // because this data should not be used for a new query\n\n    var config = this.config.keepPreviousData && prevQuery ? _extends({}, this.config, {\n      initialData: undefined\n    }) : this.config;\n    var newQuery = this.queryCache.buildQuery(config.queryKey, config);\n\n    if (newQuery === prevQuery) {\n      return false;\n    }\n\n    this.previousQueryResult = this.currentResult;\n    this.currentQuery = newQuery;\n    this.initialFetchedCount = newQuery.state.fetchedCount;\n    this.updateResult();\n\n    if (this.started) {\n      prevQuery == null ? void 0 : prevQuery.unsubscribeObserver(this);\n      this.currentQuery.subscribeObserver(this);\n    }\n\n    return true;\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(action) {\n    // Store current result and get new result\n    var prevResult = this.currentResult;\n    this.updateResult();\n    var currentResult = this.currentResult,\n        config = this.config; // We need to check the action because the state could have\n    // transitioned from success to success in case of `setQueryData`.\n\n    if (action.type === 'Success' && currentResult.isSuccess) {\n      config.onSuccess == null ? void 0 : config.onSuccess(currentResult.data);\n      config.onSettled == null ? void 0 : config.onSettled(currentResult.data, null);\n      this.updateTimers();\n    } else if (action.type === 'Error' && currentResult.isError) {\n      config.onError == null ? void 0 : config.onError(currentResult.error);\n      config.onSettled == null ? void 0 : config.onSettled(undefined, currentResult.error);\n      this.updateTimers();\n    }\n\n    if ( // Always notify on data or error change\n    currentResult.data !== prevResult.data || currentResult.error !== prevResult.error || // Maybe notify on other changes\n    config.notifyOnStatusChange) {\n      this.notify();\n    }\n  };\n\n  return QueryObserver;\n}();\n\nfunction _await$1(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch$1(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nfunction _empty$1() {}\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty$1) : Promise.resolve();\n  }\n}\n\nvar ActionType;\n\n(function (ActionType) {\n  ActionType[\"Failed\"] = \"Failed\";\n  ActionType[\"Fetch\"] = \"Fetch\";\n  ActionType[\"Success\"] = \"Success\";\n  ActionType[\"Error\"] = \"Error\";\n})(ActionType || (ActionType = {})); // CLASS\n\n\nvar Query = /*#__PURE__*/function () {\n  function Query(init) {\n    this.config = init.config;\n    this.queryCache = init.queryCache;\n    this.queryKey = init.queryKey;\n    this.queryHash = init.queryHash;\n    this.notifyGlobalListeners = init.notifyGlobalListeners;\n    this.observers = [];\n    this.state = getDefaultState(init.config);\n    this.cacheTime = init.config.cacheTime;\n    this.scheduleGc();\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.updateConfig = function updateConfig(config) {\n    this.config = config;\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime || 0);\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    this.state = queryReducer(this.state, action);\n    this.observers.forEach(function (observer) {\n      observer.onQueryUpdate(action);\n    });\n    this.notifyGlobalListeners(this);\n  };\n\n  _proto.scheduleGc = function scheduleGc() {\n    var _this = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearGcTimeout();\n\n    if (this.cacheTime === Infinity || this.observers.length > 0) {\n      return;\n    }\n\n    this.gcTimeout = setTimeout(function () {\n      _this.clear();\n    }, this.cacheTime);\n  };\n\n  _proto.cancel = function cancel() {\n    var _this$cancelFetch;\n\n    (_this$cancelFetch = this.cancelFetch) == null ? void 0 : _this$cancelFetch.call(this);\n  };\n\n  _proto.continue = function _continue() {\n    var _this$continueFetch;\n\n    (_this$continueFetch = this.continueFetch) == null ? void 0 : _this$continueFetch.call(this);\n  };\n\n  _proto.clearTimersObservers = function clearTimersObservers() {\n    this.observers.forEach(function (observer) {\n      observer.clearTimers();\n    });\n  };\n\n  _proto.clearGcTimeout = function clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  };\n\n  _proto.setData = function setData(updater) {\n    var _this$config$isDataEq, _this$config;\n\n    var prevData = this.state.data; // Get the new data\n\n    var data = functionalUpdate(updater, prevData); // Structurally share data between prev and new data if needed\n\n    if (this.config.structuralSharing) {\n      data = replaceEqualDeep(prevData, data);\n    } // Use prev data if an isDataEqual function is defined and returns `true`\n\n\n    if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {\n      data = prevData;\n    } // Try to determine if more data can be fetched\n\n\n    var canFetchMore = hasMorePages(this.config, data); // Set data and mark it as cached\n\n    this.dispatch({\n      type: ActionType.Success,\n      data: data,\n      canFetchMore: canFetchMore\n    });\n  };\n\n  _proto.clear = function clear() {\n    this.queryCache.removeQuery(this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.clearGcTimeout();\n    this.clearTimersObservers();\n    this.cancel();\n  };\n\n  _proto.isEnabled = function isEnabled() {\n    return this.observers.some(function (observer) {\n      return observer.config.enabled;\n    });\n  };\n\n  _proto.isStale = function isStale() {\n    return this.observers.some(function (observer) {\n      return observer.isStale();\n    });\n  };\n\n  _proto.isStaleByTime = function isStaleByTime(staleTime) {\n    if (staleTime === void 0) {\n      staleTime = 0;\n    }\n\n    return !this.state.isSuccess || this.state.updatedAt + staleTime <= Date.now();\n  };\n\n  _proto.onInteraction = function onInteraction(type) {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    var observer = this.observers.find(function (observer) {\n      return observer.isStale() && observer.config.enabled && (observer.config.refetchOnWindowFocus && type === 'focus' || observer.config.refetchOnReconnect && type === 'online');\n    });\n\n    if (observer) {\n      observer.fetch().catch(noop);\n    } // Continue any paused fetch\n\n\n    this.continue();\n  };\n\n  _proto.subscribe = function subscribe(listener) {\n    var observer = new QueryObserver(_extends({\n      queryCache: this.queryCache,\n      queryKey: this.queryKey\n    }, this.config));\n    observer.subscribe(listener);\n    return observer;\n  };\n\n  _proto.subscribeObserver = function subscribeObserver(observer) {\n    this.observers.push(observer); // Stop the query from being garbage collected\n\n    this.clearGcTimeout();\n  };\n\n  _proto.unsubscribeObserver = function unsubscribeObserver(observer) {\n    this.observers = this.observers.filter(function (x) {\n      return x !== observer;\n    });\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel();\n      }\n    }\n\n    this.scheduleGc();\n  };\n\n  _proto.refetch = function refetch(options, config) {\n    try {\n      var _this3 = this;\n\n      return _catch$1(function () {\n        return _await$1(_this3.fetch(undefined, config));\n      }, function (error) {\n        if ((options == null ? void 0 : options.throwOnError) === true) {\n          throw error;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options, config) {\n    try {\n      var _this5 = this;\n\n      return _this5.fetch({\n        fetchMore: {\n          fetchMoreVariable: fetchMoreVariable,\n          previous: (options == null ? void 0 : options.previous) || false\n        }\n      }, config);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.fetch = function fetch(options, config) {\n    try {\n      var _this7 = this; // If we are already fetching, return current promise\n\n\n      if (_this7.promise) {\n        return _this7.promise;\n      } // Update config if passed, otherwise the config from the last execution is used\n\n\n      if (config) {\n        _this7.updateConfig(config);\n      }\n\n      config = _this7.config; // Check if there is a query function\n\n      if (typeof config.queryFn !== 'function') {\n        return;\n      } // Get the query function params\n\n\n      var filter = config.queryFnParamsFilter;\n      var params = filter ? filter(_this7.queryKey) : _this7.queryKey;\n      _this7.promise = _async(function () {\n        return _catch$1(function () {\n          var data;\n          return _invoke(function () {\n            if (config.infinite) {\n              return _await$1(_this7.startInfiniteFetch(config, params, options), function (_this7$startInfiniteF) {\n                data = _this7$startInfiniteF;\n              });\n            } else {\n              return _await$1(_this7.startFetch(config, params, options), function (_this7$startFetch) {\n                data = _this7$startFetch;\n              });\n            }\n          }, function () {\n            // Set success state\n            _this7.setData(data); // Cleanup\n\n\n            delete _this7.promise; // Return data\n\n            return data;\n          });\n        }, function (error) {\n          // Set error state\n          _this7.dispatch({\n            type: ActionType.Error,\n            error: error\n          }); // Log error\n\n\n          if (!isCancelledError(error)) {\n            Console.error(error);\n          } // Cleanup\n\n\n          delete _this7.promise; // Propagate error\n\n          throw error;\n        });\n      })();\n      return _this7.promise;\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.startFetch = function startFetch(config, params, _options) {\n    try {\n      var _this9 = this; // Create function to fetch the data\n\n\n      var fetchData = function fetchData() {\n        return config.queryFn.apply(void 0, params);\n      }; // Set to fetching state if not already in it\n\n\n      if (!_this9.state.isFetching) {\n        _this9.dispatch({\n          type: ActionType.Fetch\n        });\n      } // Try to fetch the data\n\n\n      return _this9.tryFetchData(config, fetchData);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.startInfiniteFetch = function startInfiniteFetch(config, params, options) {\n    try {\n      var _this11 = this;\n\n      var fetchMore = options == null ? void 0 : options.fetchMore;\n\n      var _ref = fetchMore || {},\n          previous = _ref.previous,\n          fetchMoreVariable = _ref.fetchMoreVariable;\n\n      var isFetchingMore = fetchMore ? previous ? 'previous' : 'next' : false;\n      var prevPages = _this11.state.data || []; // Create function to fetch a page\n\n      var fetchPage = _async(function (pages, prepend, cursor) {\n        var lastPage = getLastPage(pages, prepend);\n\n        if (typeof cursor === 'undefined' && typeof lastPage !== 'undefined' && config.getFetchMore) {\n          cursor = config.getFetchMore(lastPage, pages);\n        }\n\n        return _await$1(config.queryFn.apply(void 0, params.concat([cursor])), function (page) {\n          return prepend ? [page].concat(pages) : [].concat(pages, [page]);\n        });\n      }); // Create function to fetch the data\n\n\n      var fetchData = function fetchData() {\n        if (isFetchingMore) {\n          return fetchPage(prevPages, previous, fetchMoreVariable);\n        } else if (!prevPages.length) {\n          return fetchPage([]);\n        } else {\n          var promise = fetchPage([]);\n\n          for (var i = 1; i < prevPages.length; i++) {\n            promise = promise.then(fetchPage);\n          }\n\n          return promise;\n        }\n      }; // Set to fetching state if not already in it\n\n\n      if (!_this11.state.isFetching) {\n        _this11.dispatch({\n          type: ActionType.Fetch,\n          isFetchingMore: isFetchingMore\n        });\n      } // Try to get the data\n\n\n      return _this11.tryFetchData(config, fetchData);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.tryFetchData = function tryFetchData(config, fn) {\n    try {\n      var _this13 = this;\n\n      return new Promise(function (outerResolve, outerReject) {\n        var resolved = false;\n        var continueLoop;\n        var cancelTransport;\n\n        var done = function done() {\n          resolved = true;\n          delete _this13.cancelFetch;\n          delete _this13.continueFetch;\n          delete _this13.isTransportCancelable; // End loop if currently paused\n\n          continueLoop == null ? void 0 : continueLoop();\n        };\n\n        var resolve = function resolve(value) {\n          done();\n          outerResolve(value);\n        };\n\n        var reject = function reject(value) {\n          done();\n          outerReject(value);\n        }; // Create callback to cancel this fetch\n\n\n        _this13.cancelFetch = function () {\n          reject(new CancelledError());\n\n          try {\n            cancelTransport == null ? void 0 : cancelTransport();\n          } catch (_unused) {}\n        }; // Create callback to continue this fetch\n\n\n        _this13.continueFetch = function () {\n          continueLoop == null ? void 0 : continueLoop();\n        }; // Create loop function\n\n\n        var run = _async(function () {\n          return _catch$1(function () {\n            // Execute query\n            var promiseOrValue = fn(); // Check if the transport layer support cancellation\n\n            if (isCancelable(promiseOrValue)) {\n              cancelTransport = function cancelTransport() {\n                promiseOrValue.cancel();\n              };\n\n              _this13.isTransportCancelable = true;\n            } // Await data\n\n\n            return _await$1(promiseOrValue, function (_promiseOrValue) {\n              resolve(_promiseOrValue);\n            });\n          }, function (error) {\n            // Stop if the fetch is already resolved\n            if (resolved) {\n              return;\n            } // Do we need to retry the request?\n\n\n            var failureCount = _this13.state.failureCount;\n            var retry = config.retry,\n                retryDelay = config.retryDelay;\n            var shouldRetry = retry === true || failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n            if (!shouldRetry) {\n              // We are done if the query does not need to be retried\n              reject(error);\n              return;\n            } // Increase the failureCount\n\n\n            _this13.dispatch({\n              type: ActionType.Failed\n            }); // Delay\n\n\n            return _await$1(sleep(functionalUpdate(retryDelay, failureCount) || 0), function () {\n              // Pause retry if the document is not visible or when the device is offline\n              return _invoke(function () {\n                if (!isDocumentVisible() || !isOnline()) {\n                  return _awaitIgnored(new Promise(function (continueResolve) {\n                    continueLoop = continueResolve;\n                  }));\n                }\n              }, function () {\n                if (!resolved) {\n                  run();\n                }\n              }); // Try again if not resolved yet\n            });\n          });\n        }); // Start loop\n\n\n        run();\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return Query;\n}();\n\nfunction getLastPage(pages, previous) {\n  return previous ? pages[0] : pages[pages.length - 1];\n}\n\nfunction hasMorePages(config, pages, previous) {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages));\n  }\n}\n\nfunction getDefaultState(config) {\n  var initialData = typeof config.initialData === 'function' ? config.initialData() : config.initialData;\n  var hasInitialData = typeof initialData !== 'undefined';\n  var initialStatus = hasInitialData ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;\n  return _extends({}, getStatusProps(initialStatus), {\n    error: null,\n    isFetched: false,\n    isFetching: initialStatus === QueryStatus.Loading,\n    isFetchingMore: false,\n    failureCount: 0,\n    fetchedCount: 0,\n    data: initialData,\n    updatedAt: Date.now(),\n    canFetchMore: hasMorePages(config, initialData)\n  });\n}\n\nfunction queryReducer(state, action) {\n  switch (action.type) {\n    case ActionType.Failed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case ActionType.Fetch:\n      var status = typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading;\n      return _extends({}, state, getStatusProps(status), {\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        failureCount: 0\n      });\n\n    case ActionType.Success:\n      return _extends({}, state, getStatusProps(QueryStatus.Success), {\n        data: action.data,\n        error: null,\n        fetchedCount: state.fetchedCount + 1,\n        isFetched: true,\n        isFetching: false,\n        isFetchingMore: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0\n      });\n\n    case ActionType.Error:\n      return _extends({}, state, getStatusProps(QueryStatus.Error), {\n        error: action.error,\n        fetchedCount: state.fetchedCount + 1,\n        isFetched: true,\n        isFetching: false,\n        isFetchingMore: false,\n        failureCount: state.failureCount + 1,\n        throwInErrorBoundary: true\n      });\n\n    default:\n      return state;\n  }\n} // CLASS\n\n\nfunction _empty$2() {}\n\nfunction _awaitIgnored$1(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty$2) : Promise.resolve();\n  }\n}\n\nfunction _catch$2(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _invoke$1(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nvar QueryCache = /*#__PURE__*/function () {\n  function QueryCache(config) {\n    this.config = config || {}; // A frozen cache does not add new queries to the cache\n\n    this.globalListeners = [];\n    this.queries = {};\n    this.queriesArray = [];\n    this.isFetching = 0;\n  }\n\n  var _proto = QueryCache.prototype;\n\n  _proto.notifyGlobalListeners = function notifyGlobalListeners(query) {\n    var _this = this;\n\n    this.isFetching = this.getQueries().reduce(function (acc, query) {\n      return query.state.isFetching ? acc + 1 : acc;\n    }, 0);\n    this.globalListeners.forEach(function (listener) {\n      listener(_this, query);\n    });\n  };\n\n  _proto.getDefaultConfig = function getDefaultConfig() {\n    return this.config.defaultConfig;\n  };\n\n  _proto.getDefaultedQueryConfig = function getDefaultedQueryConfig$1(config) {\n    return getDefaultedQueryConfig(this.getDefaultConfig(), undefined, config, {\n      queryCache: this\n    });\n  };\n\n  _proto.subscribe = function subscribe(listener) {\n    var _this2 = this;\n\n    this.globalListeners.push(listener);\n    return function () {\n      _this2.globalListeners = _this2.globalListeners.filter(function (x) {\n        return x !== listener;\n      });\n    };\n  };\n\n  _proto.clear = function clear(options) {\n    this.removeQueries();\n\n    if (options == null ? void 0 : options.notify) {\n      this.notifyGlobalListeners();\n    }\n  };\n\n  _proto.getQueries = function getQueries(predicate, options) {\n    if (predicate === true || typeof predicate === 'undefined') {\n      return this.queriesArray;\n    }\n\n    var predicateFn;\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate;\n    } else {\n      var _config = this.getDefaultedQueryConfig();\n\n      var _ref = _config.queryKeySerializerFn(predicate),\n          queryHash = _ref[0],\n          _queryKey = _ref[1];\n\n      predicateFn = function predicateFn(d) {\n        return (options == null ? void 0 : options.exact) ? d.queryHash === queryHash : deepIncludes(d.queryKey, _queryKey);\n      };\n    }\n\n    return this.queriesArray.filter(predicateFn);\n  };\n\n  _proto.getQuery = function getQuery(predicate) {\n    return this.getQueries(predicate, {\n      exact: true\n    })[0];\n  };\n\n  _proto.getQueryData = function getQueryData(predicate) {\n    var _this$getQuery;\n\n    return (_this$getQuery = this.getQuery(predicate)) == null ? void 0 : _this$getQuery.state.data;\n  };\n\n  _proto.removeQuery = function removeQuery(query) {\n    if (this.queries[query.queryHash]) {\n      query.destroy();\n      delete this.queries[query.queryHash];\n      this.queriesArray = this.queriesArray.filter(function (x) {\n        return x !== query;\n      });\n      this.notifyGlobalListeners(query);\n    }\n  };\n\n  _proto.removeQueries = function removeQueries(predicate, options) {\n    var _this3 = this;\n\n    this.getQueries(predicate, options).forEach(function (query) {\n      _this3.removeQuery(query);\n    });\n  };\n\n  _proto.cancelQueries = function cancelQueries(predicate, options) {\n    this.getQueries(predicate, options).forEach(function (query) {\n      query.cancel();\n    });\n  };\n\n  _proto.invalidateQueries = function invalidateQueries(predicate, options) {\n    try {\n      var _this5 = this;\n\n      var _ref2 = options || {},\n          _ref2$refetchActive = _ref2.refetchActive,\n          refetchActive = _ref2$refetchActive === void 0 ? true : _ref2$refetchActive,\n          _ref2$refetchInactive = _ref2.refetchInactive,\n          refetchInactive = _ref2$refetchInactive === void 0 ? false : _ref2$refetchInactive,\n          throwOnError = _ref2.throwOnError;\n\n      return _catch$2(function () {\n        return _awaitIgnored$1(Promise.all(_this5.getQueries(predicate, options).map(function (query) {\n          var enabled = query.isEnabled();\n\n          if (enabled && refetchActive || !enabled && refetchInactive) {\n            return query.fetch();\n          }\n\n          return undefined;\n        })));\n      }, function (err) {\n        if (throwOnError) {\n          throw err;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.resetErrorBoundaries = function resetErrorBoundaries() {\n    this.getQueries().forEach(function (query) {\n      query.state.throwInErrorBoundary = false;\n    });\n  };\n\n  _proto.buildQuery = function buildQuery(userQueryKey, queryConfig) {\n    var _this6 = this;\n\n    var config = this.getDefaultedQueryConfig(queryConfig);\n\n    var _ref3 = config.queryKeySerializerFn(userQueryKey),\n        queryHash = _ref3[0],\n        queryKey = _ref3[1];\n\n    if (this.queries[queryHash]) {\n      return this.queries[queryHash];\n    }\n\n    var query = new Query({\n      queryCache: this,\n      queryKey: queryKey,\n      queryHash: queryHash,\n      config: config,\n      notifyGlobalListeners: function notifyGlobalListeners(query) {\n        _this6.notifyGlobalListeners(query);\n      }\n    });\n\n    if (!this.config.frozen) {\n      this.queries[queryHash] = query;\n      this.queriesArray.push(query);\n      this.notifyGlobalListeners(query);\n    }\n\n    return query;\n  } // Parameter syntax with optional prefetch options\n  ; // Implementation\n\n\n  _proto.prefetchQuery = function prefetchQuery() {\n    try {\n      var _this8 = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (isObject(args[1]) && (args[1].hasOwnProperty('throwOnError') || args[1].hasOwnProperty('force'))) {\n        args[3] = args[1];\n        args[1] = undefined;\n        args[2] = undefined;\n      }\n\n      var _getQueryArgs = getQueryArgs(args),\n          _queryKey2 = _getQueryArgs[0],\n          _config2 = _getQueryArgs[1],\n          _options = _getQueryArgs[2]; // https://github.com/tannerlinsley/react-query/issues/652\n\n\n      var configWithoutRetry = _this8.getDefaultedQueryConfig(_extends({\n        retry: false\n      }, _config2));\n\n      var _query;\n\n      return _catch$2(function () {\n        _query = _this8.buildQuery(_queryKey2, configWithoutRetry);\n        return _invoke$1(function () {\n          if ((_options == null ? void 0 : _options.force) || _query.isStaleByTime(_config2.staleTime)) {\n            return _awaitIgnored$1(_query.fetch(undefined, configWithoutRetry));\n          }\n        }, function () {\n          return _query.state.data;\n        });\n      }, function (error) {\n        if (_options == null ? void 0 : _options.throwOnError) {\n          throw error;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.setQueryData = function setQueryData(queryKey, updater, config) {\n    var query = this.getQuery(queryKey);\n\n    if (query) {\n      query.setData(updater);\n      return;\n    }\n\n    this.buildQuery(queryKey, _extends({\n      initialStale: typeof (config == null ? void 0 : config.staleTime) === 'undefined',\n      initialData: functionalUpdate(updater, undefined)\n    }, config));\n  };\n\n  return QueryCache;\n}();\n\nvar defaultQueryCache = makeQueryCache({\n  frozen: isServer\n});\nvar queryCaches = [defaultQueryCache];\n\nfunction makeQueryCache(config) {\n  return new QueryCache(config);\n}\n\nfunction onVisibilityOrOnlineChange(type) {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(function (queryCache) {\n      queryCache.getQueries().forEach(function (query) {\n        query.onInteraction(type);\n      });\n    });\n  }\n}\n\nvar setFocusHandler = createSetHandler(function () {\n  return onVisibilityOrOnlineChange('focus');\n});\nsetFocusHandler(function (handleFocus) {\n  var _window;\n\n  if (isServer || !((_window = window) == null ? void 0 : _window.addEventListener)) {\n    return;\n  } // Listen to visibillitychange and focus\n\n\n  window.addEventListener('visibilitychange', handleFocus, false);\n  window.addEventListener('focus', handleFocus, false);\n  return function () {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('visibilitychange', handleFocus);\n    window.removeEventListener('focus', handleFocus);\n  };\n});\nvar setOnlineHandler = createSetHandler(function () {\n  return onVisibilityOrOnlineChange('online');\n});\nsetOnlineHandler(function (handleOnline) {\n  var _window;\n\n  if (isServer || !((_window = window) == null ? void 0 : _window.addEventListener)) {\n    return;\n  } // Listen to online\n\n\n  window.addEventListener('online', handleOnline, false);\n  return function () {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('online', handleOnline);\n  };\n});\nvar queryCacheContext = React.createContext(defaultQueryCache);\n\nvar useQueryCache = function useQueryCache() {\n  return React.useContext(queryCacheContext);\n};\n\nvar ReactQueryCacheProvider = function ReactQueryCacheProvider(_ref) {\n  var queryCache = _ref.queryCache,\n      children = _ref.children;\n  var resolvedQueryCache = React.useMemo(function () {\n    return queryCache || makeQueryCache();\n  }, [queryCache]);\n  React.useEffect(function () {\n    queryCaches.push(resolvedQueryCache);\n    return function () {\n      // remove the cache from the active list\n      var i = queryCaches.indexOf(resolvedQueryCache);\n\n      if (i > -1) {\n        queryCaches.splice(i, 1);\n      } // if the resolvedQueryCache was created by us, we need to tear it down\n\n\n      if (queryCache == null) {\n        resolvedQueryCache.clear({\n          notify: false\n        });\n      }\n    };\n  }, [resolvedQueryCache, queryCache]);\n  return /*#__PURE__*/React.createElement(queryCacheContext.Provider, {\n    value: resolvedQueryCache\n  }, children);\n};\n\nvar configContext = React.createContext(undefined);\n\nfunction useContextConfig() {\n  return React.useContext(configContext);\n}\n\nvar ReactQueryConfigProvider = function ReactQueryConfigProvider(_ref) {\n  var config = _ref.config,\n      children = _ref.children;\n  var parentConfig = useContextConfig();\n  var mergedConfig = React.useMemo(function () {\n    return parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config;\n  }, [config, parentConfig]);\n  return /*#__PURE__*/React.createElement(configContext.Provider, {\n    value: mergedConfig\n  }, children);\n};\n\nfunction useGetLatest(obj) {\n  var ref = React.useRef(obj);\n  ref.current = obj;\n  return React.useCallback(function () {\n    return ref.current;\n  }, []);\n}\n\nfunction useIsMounted() {\n  var mountedRef = React.useRef(false);\n  var isMounted = React.useCallback(function () {\n    return mountedRef.current;\n  }, []);\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](function () {\n    mountedRef.current = true;\n    return function () {\n      mountedRef.current = false;\n    };\n  }, []);\n  return isMounted;\n}\n\nfunction useMountedCallback(callback) {\n  var isMounted = useIsMounted();\n  return React.useCallback(function () {\n    if (isMounted()) {\n      return callback.apply(void 0, arguments);\n    }\n  }, [callback, isMounted]);\n}\n/**\n * This hook is a safe useState version which schedules state updates in microtasks\n * to prevent updating a component state while React is rendering different components\n * or when the component is not mounted anymore.\n */\n\n\nfunction useSafeState(initialState) {\n  var isMounted = useIsMounted();\n\n  var _React$useState = React.useState(initialState),\n      state = _React$useState[0],\n      setState = _React$useState[1];\n\n  var safeSetState = React.useCallback(function (value) {\n    scheduleMicrotask(function () {\n      if (isMounted()) {\n        setState(value);\n      }\n    });\n  }, [isMounted]);\n  return [state, safeSetState];\n}\n\nfunction useRerenderer() {\n  var _useSafeState = useSafeState({}),\n      setState = _useSafeState[1];\n\n  return React.useCallback(function () {\n    return setState({});\n  }, [setState]);\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\n\nfunction scheduleMicrotask(callback) {\n  Promise.resolve().then(callback).catch(function (error) {\n    return setTimeout(function () {\n      throw error;\n    });\n  });\n}\n\nfunction useIsFetching() {\n  var queryCache = useQueryCache();\n\n  var _useSafeState = useSafeState(queryCache.isFetching),\n      isFetching = _useSafeState[0],\n      setIsFetching = _useSafeState[1];\n\n  React.useEffect(function () {\n    return queryCache.subscribe(function () {\n      setIsFetching(queryCache.isFetching);\n    });\n  }, [queryCache, setIsFetching]);\n  return isFetching;\n}\n\nfunction useDefaultedMutationConfig(config) {\n  var contextConfig = useContextConfig();\n  var contextQueryCache = useQueryCache();\n  var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;\n  var queryCacheConfig = queryCache.getDefaultConfig();\n  return getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, {\n    queryCache: queryCache\n  });\n}\n\nfunction _await$2(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nvar ActionType$1;\n\nfunction _catch$3(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async$1(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\n(function (ActionType) {\n  ActionType[\"Reset\"] = \"Reset\";\n  ActionType[\"Loading\"] = \"Loading\";\n  ActionType[\"Resolve\"] = \"Resolve\";\n  ActionType[\"Reject\"] = \"Reject\";\n})(ActionType$1 || (ActionType$1 = {})); // HOOK\n\n\nvar getDefaultState$1 = function getDefaultState() {\n  return _extends({}, getStatusProps(QueryStatus.Idle), {\n    data: undefined,\n    error: null\n  });\n};\n\nfunction mutationReducer(state, action) {\n  switch (action.type) {\n    case ActionType$1.Reset:\n      return getDefaultState$1();\n\n    case ActionType$1.Loading:\n      return _extends({}, getStatusProps(QueryStatus.Loading), {\n        data: undefined,\n        error: null\n      });\n\n    case ActionType$1.Resolve:\n      return _extends({}, getStatusProps(QueryStatus.Success), {\n        data: action.data,\n        error: null\n      });\n\n    case ActionType$1.Reject:\n      return _extends({}, getStatusProps(QueryStatus.Error), {\n        data: undefined,\n        error: action.error\n      });\n\n    default:\n      return state;\n  }\n}\n\nfunction useMutation(mutationFn, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  config = useDefaultedMutationConfig(config);\n  var getConfig = useGetLatest(config);\n\n  var _React$useReducer = React.useReducer(mutationReducer, null, getDefaultState$1),\n      state = _React$useReducer[0],\n      unsafeDispatch = _React$useReducer[1];\n\n  var dispatch = useMountedCallback(unsafeDispatch);\n  var getMutationFn = useGetLatest(mutationFn);\n  var latestMutationRef = React.useRef();\n  var mutate = React.useCallback(_async$1(function (variables, mutateConfig) {\n    if (mutateConfig === void 0) {\n      mutateConfig = {};\n    }\n\n    var config = getConfig();\n    var mutationId = uid();\n    latestMutationRef.current = mutationId;\n\n    var isLatest = function isLatest() {\n      return latestMutationRef.current === mutationId;\n    };\n\n    var snapshotValue;\n    return _catch$3(function () {\n      dispatch({\n        type: ActionType$1.Loading\n      });\n      return _await$2(config.onMutate == null ? void 0 : config.onMutate(variables), function (_config$onMutate) {\n        snapshotValue = _config$onMutate;\n        return _await$2(getMutationFn()(variables), function (data) {\n          if (isLatest()) {\n            dispatch({\n              type: ActionType$1.Resolve,\n              data: data\n            });\n          }\n\n          return _await$2(config.onSuccess == null ? void 0 : config.onSuccess(data, variables), function () {\n            return _await$2(mutateConfig.onSuccess == null ? void 0 : mutateConfig.onSuccess(data, variables), function () {\n              return _await$2(config.onSettled == null ? void 0 : config.onSettled(data, null, variables), function () {\n                return _await$2(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(data, null, variables), function () {\n                  return data;\n                });\n              });\n            });\n          });\n        });\n      });\n    }, function (error) {\n      Console.error(error);\n      return _await$2(config.onError == null ? void 0 : config.onError(error, variables, snapshotValue), function () {\n        return _await$2(mutateConfig.onError == null ? void 0 : mutateConfig.onError(error, variables, snapshotValue), function () {\n          return _await$2(config.onSettled == null ? void 0 : config.onSettled(undefined, error, variables, snapshotValue), function () {\n            return _await$2(mutateConfig.onSettled == null ? void 0 : mutateConfig.onSettled(undefined, error, variables, snapshotValue), function () {\n              var _mutateConfig$throwOn;\n\n              if (isLatest()) {\n                dispatch({\n                  type: ActionType$1.Reject,\n                  error: error\n                });\n              }\n\n              if ((_mutateConfig$throwOn = mutateConfig.throwOnError) != null ? _mutateConfig$throwOn : config.throwOnError) {\n                throw error;\n              }\n            });\n          });\n        });\n      });\n    });\n  }), [dispatch, getConfig, getMutationFn]);\n  var reset = React.useCallback(function () {\n    dispatch({\n      type: ActionType$1.Reset\n    });\n  }, [dispatch]);\n  React.useEffect(function () {\n    var _getConfig = getConfig(),\n        suspense = _getConfig.suspense,\n        useErrorBoundary = _getConfig.useErrorBoundary;\n\n    if ((useErrorBoundary != null ? useErrorBoundary : suspense) && state.error) {\n      throw state.error;\n    }\n  }, [getConfig, state.error]);\n  return [mutate, _extends({}, state, {\n    reset: reset\n  })];\n}\n\nfunction useDefaultedQueryConfig(config) {\n  var contextConfig = useContextConfig();\n  var contextQueryCache = useQueryCache();\n  var queryCache = (config == null ? void 0 : config.queryCache) || contextQueryCache;\n  var queryCacheConfig = queryCache.getDefaultConfig();\n  return getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, {\n    queryCache: queryCache\n  });\n}\n\nfunction useBaseQuery(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  config = useDefaultedQueryConfig(config); // Make a rerender function\n\n  var rerender = useRerenderer(); // Create query observer\n\n  var observerRef = React.useRef();\n  var firstRender = !observerRef.current;\n  var observer = observerRef.current || new QueryObserver(config);\n  observerRef.current = observer; // Subscribe to the observer\n\n  React.useEffect(function () {\n    return observer.subscribe(function () {\n      rerender();\n    });\n  }, [observer, rerender]); // Update config\n\n  if (!firstRender) {\n    observer.updateConfig(config);\n  }\n\n  var result = observer.getCurrentResult(); // Handle suspense\n\n  if (config.suspense || config.useErrorBoundary) {\n    var query = observer.getCurrentQuery();\n\n    if (result.isError && query.state.throwInErrorBoundary) {\n      throw result.error;\n    }\n\n    if (config.enabled && config.suspense && !result.isSuccess) {\n      var unsubscribe = observer.subscribe();\n      throw observer.fetch().finally(unsubscribe);\n    }\n  }\n\n  return result;\n} // Implementation\n\n\nfunction useQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var config = getQueryArgs(args)[1];\n  return useBaseQuery(config);\n} // as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n// TYPES\n// Implementation\n\n\nfunction usePaginatedQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var config = getQueryArgs(args)[1];\n  var result = useBaseQuery(_extends({\n    keepPreviousData: true\n  }, config));\n  return _extends({}, result, {\n    resolvedData: result.data,\n    latestData: result.isPreviousData ? undefined : result.data\n  });\n} // Implementation\n\n\nfunction useInfiniteQuery() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var config = getQueryArgs(args)[1];\n  return useBaseQuery(_extends({}, config, {\n    infinite: true\n  }));\n}\n\nexport { CancelledError, QueryStatus, ReactQueryCacheProvider, ReactQueryConfigProvider, isCancelledError, isError, makeQueryCache, defaultQueryCache as queryCache, queryCaches, setConsole, setFocusHandler, setOnlineHandler, useInfiniteQuery, useIsFetching, useMutation, usePaginatedQuery, useQuery, useQueryCache };","map":{"version":3,"sources":["../src/core/types.ts","../src/core/utils.ts","../src/core/config.ts","../src/core/queryObserver.ts","../src/core/query.ts","../src/core/queryCache.ts","../src/core/setFocusHandler.ts","../src/core/setOnlineHandler.ts","../src/react/ReactQueryCacheProvider.tsx","../src/react/ReactQueryConfigProvider.tsx","../src/react/utils.ts","../src/react/useIsFetching.ts","../src/react/useDefaultedMutationConfig.tsx","../src/react/useMutation.ts","../src/react/useDefaultedQueryConfig.tsx","../src/react/useBaseQuery.ts","../src/react/useQuery.ts","../src/react/usePaginatedQuery.ts","../src/react/useInfiniteQuery.ts"],"names":["QueryStatus","CancelledError","_uid","uid","isServer","Console","console","error","warn","log","noop","updater","isObject","result","value","JSON","a","deepIncludes","b","document","navigator","args","queryKey","queryFn","config","options","array","Array","isPlainObject","aSize","Object","bItems","bSize","copy","equalItems","i","key","replaceEqualDeep","hasObjectPrototype","ctor","o","prot","setTimeout","status","isLoading","isSuccess","isError","isIdle","Idle","removePreviousHandler","callback","defaultQueryKeySerializerFn","arrayQueryKey","queryHash","stableStringify","DEFAULT_STALE_TIME","DEFAULT_CACHE_TIME","DEFAULT_CONFIG","queries","cacheTime","enabled","notifyOnStatusChange","queryKeySerializerFn","refetchOnMount","refetchOnReconnect","refetchOnWindowFocus","retry","retryDelay","Math","staleTime","structuralSharing","shared","mutations","queryCacheConfig","contextConfig","QueryObserver","subscribe","unsubscribe","updateConfig","prevConfig","updated","then","Promise","isStale","getCurrentQuery","getCurrentResult","clear","updatedAt","timeElapsed","Date","timeUntilStale","timeout","setInterval","isDocumentVisible","updateTimers","clearTimers","clearInterval","currentQuery","currentResult","previousQueryResult","state","data","isPreviousData","getStatusProps","canFetchMore","failureCount","fetchMore","isFetched","isFetchedAfterMount","isFetching","isFetchingMore","refetch","prevQuery","initialData","undefined","newQuery","onQueryUpdate","prevResult","action","body","recover","ActionType","arguments","f","Query","init","getDefaultState","queryReducer","observer","cancel","clearTimeout","setData","prevData","functionalUpdate","hasMorePages","type","destroy","isEnabled","isStaleByTime","onInteraction","queryCache","subscribeObserver","unsubscribeObserver","x","fetchMoreVariable","previous","filter","params","isCancelledError","fetchData","Fetch","prevPages","fetchPage","lastPage","getLastPage","cursor","prepend","promise","resolved","done","continueLoop","resolve","outerResolve","reject","outerReject","cancelTransport","run","promiseOrValue","fn","isCancelable","shouldRetry","Failed","sleep","isOnline","pages","Boolean","hasInitialData","initialStatus","fetchedCount","throwInErrorBoundary","QueryCache","query","acc","listener","getDefaultConfig","getDefaultedQueryConfig","getQueries","predicate","predicateFn","d","getQuery","exact","getQueryData","removeQuery","removeQueries","cancelQueries","refetchActive","refetchInactive","throwOnError","resetErrorBoundaries","buildQuery","notifyGlobalListeners","getQueryArgs","configWithoutRetry","setQueryData","initialStale","defaultQueryCache","makeQueryCache","frozen","queryCaches","setFocusHandler","createSetHandler","onVisibilityOrOnlineChange","window","setOnlineHandler","queryCacheContext","React","useQueryCache","ReactQueryCacheProvider","children","resolvedQueryCache","notify","configContext","ReactQueryConfigProvider","parentConfig","useContextConfig","mergedConfig","mergeReactQueryConfigs","ref","mountedRef","isMounted","useIsMounted","setState","safeSetState","scheduleMicrotask","useSafeState","setIsFetching","contextQueryCache","getDefaultedMutationConfig","useDefaultedMutationConfig","getConfig","useGetLatest","unsafeDispatch","dispatch","useMountedCallback","getMutationFn","latestMutationRef","mutate","mutateConfig","mutationId","isLatest","Loading","snapshotValue","reset","Reset","suspense","useErrorBoundary","useDefaultedQueryConfig","rerender","useRerenderer","observerRef","firstRender","useBaseQuery","keepPreviousData","resolvedData","latestData","infinite"],"mappings":"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","sourcesContent":["import type { FetchMoreOptions, RefetchOptions } from './query'\nimport type { QueryCache } from './queryCache'\n\nexport type QueryKey =\n  | boolean\n  | null\n  | number\n  | object\n  | string\n  | undefined\n  | { [key: number]: QueryKey }\n  | { [key: string]: QueryKey }\n  | readonly QueryKey[]\n\nexport type ArrayQueryKey = QueryKey[]\n\nexport type QueryFunction<TResult> = (\n  ...args: any[]\n) => TResult | Promise<TResult>\n\nexport type TypedQueryFunction<\n  TResult,\n  TArgs extends TypedQueryFunctionArgs = TypedQueryFunctionArgs\n> = (...args: TArgs) => TResult | Promise<TResult>\n\nexport type TypedQueryFunctionArgs = readonly [unknown, ...unknown[]]\n\nexport type InitialDataFunction<TResult> = () => TResult | undefined\n\nexport type InitialStaleFunction = () => boolean\n\nexport type QueryKeySerializerFunction = (\n  queryKey: QueryKey\n) => [string, QueryKey[]]\n\nexport interface BaseQueryConfig<TResult, TError = unknown, TData = TResult> {\n  /**\n   * If `false`, failed queries will not retry by default.\n   * If `true`, failed queries will retry infinitely., failureCount: num\n   * If set to an integer number, e.g. 3, failed queries will retry until the failed query count meets that number.\n   * If set to a function `(failureCount, error) => boolean` failed queries will retry until the function returns false.\n   */\n  retry?: boolean | number | ((failureCount: number, error: TError) => boolean)\n  retryDelay?: number | ((retryAttempt: number) => number)\n  staleTime?: number\n  cacheTime?: number\n  isDataEqual?: (oldData: unknown, newData: unknown) => boolean\n  queryFn?: QueryFunction<TData>\n  queryKey?: QueryKey\n  queryKeySerializerFn?: QueryKeySerializerFunction\n  queryFnParamsFilter?: (args: ArrayQueryKey) => ArrayQueryKey\n  initialData?: TResult | InitialDataFunction<TResult>\n  initialStale?: boolean | InitialStaleFunction\n  infinite?: true\n  /**\n   * Set this to `false` to disable structural sharing between query results.\n   * Defaults to `true`.\n   */\n  structuralSharing?: boolean\n  /**\n   * This function can be set to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `canFetchMore`.\n   */\n  getFetchMore?: (lastPage: TData, allPages: TData[]) => unknown\n}\n\nexport interface QueryObserverConfig<\n  TResult,\n  TError = unknown,\n  TData = TResult\n> extends BaseQueryConfig<TResult, TError, TData> {\n  /**\n   * Set this to `false` to disable automatic refetching when the query mounts or changes query keys.\n   * To refetch the query, use the `refetch` method returned from the `useQuery` instance.\n   * Defaults to `true`.\n   */\n  enabled?: boolean | unknown\n  /**\n   * If set to a number, the query will continuously refetch at this frequency in milliseconds.\n   * Defaults to `false`.\n   */\n  refetchInterval?: number | false\n  /**\n   * If set to `true`, the query will continue to refetch while their tab/window is in the background.\n   * Defaults to `false`.\n   */\n  refetchIntervalInBackground?: boolean\n  /**\n   * Set this to `true` or `false` to enable/disable automatic refetching on window focus for this query.\n   * Defaults to `true`.\n   */\n  refetchOnWindowFocus?: boolean\n  /**\n   * Set this to `true` or `false` to enable/disable automatic refetching on reconnect for this query.\n   * Defaults to `true`.\n   */\n  refetchOnReconnect?: boolean\n  /**\n   * If set to `false`, will disable additional instances of a query to trigger background refetches.\n   * Defaults to `true`.\n   */\n  refetchOnMount?: boolean\n  /**\n   * Set this to `true` to always fetch when the component mounts (regardless of staleness).\n   * Defaults to `false`.\n   */\n  forceFetchOnMount?: boolean\n  /**\n   * Whether a change to the query status should re-render a component.\n   * If set to `false`, the component will only re-render when the actual `data` or `error` changes.\n   * Defaults to `true`.\n   */\n  notifyOnStatusChange?: boolean\n  /**\n   * This callback will fire any time the query successfully fetches new data.\n   */\n  onSuccess?: (data: TResult) => void\n  /**\n   * This callback will fire if the query encounters an error and will be passed the error.\n   */\n  onError?: (err: TError) => void\n  /**\n   * This callback will fire any time the query is either successfully fetched or errors and be passed either the data or error.\n   */\n  onSettled?: (data: TResult | undefined, error: TError | null) => void\n  /**\n   * Whether errors should be thrown instead of setting the `error` property.\n   * Defaults to `false`.\n   */\n  useErrorBoundary?: boolean\n  /**\n   * If set to `true`, the query will suspend when `status === 'loading'`\n   * and throw errors when `status === 'error'`.\n   * Defaults to `false`.\n   */\n  suspense?: boolean\n  /**\n   * Set this to `true` to keep the previous `data` when fetching based on a new query key.\n   * Defaults to `false`.\n   */\n  keepPreviousData?: boolean\n  /**\n   * By default the query cache from the context is used, but a different cache can be specified.\n   */\n  queryCache?: QueryCache\n}\n\nexport interface QueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface PaginatedQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface InfiniteQueryConfig<TResult, TError = unknown>\n  extends QueryObserverConfig<TResult[], TError, TResult> {}\n\nexport type IsFetchingMoreValue = 'previous' | 'next' | false\n\nexport enum QueryStatus {\n  Idle = 'idle',\n  Loading = 'loading',\n  Error = 'error',\n  Success = 'success',\n}\n\nexport interface QueryResultBase<TResult, TError = unknown> {\n  canFetchMore: boolean | undefined\n  clear: () => void\n  data: TResult | undefined\n  error: TError | null\n  failureCount: number\n  fetchMore: (\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ) => Promise<TResult | undefined>\n  isError: boolean\n  isFetched: boolean\n  isFetchedAfterMount: boolean\n  isFetching: boolean\n  isFetchingMore?: IsFetchingMoreValue\n  isIdle: boolean\n  isLoading: boolean\n  isStale: boolean\n  isSuccess: boolean\n  isPreviousData: boolean\n  refetch: (options?: RefetchOptions) => Promise<TResult | undefined>\n  status: QueryStatus\n  updatedAt: number\n}\n\nexport interface QueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {}\n\nexport interface PaginatedQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult, TError> {\n  resolvedData: TResult | undefined\n  latestData: TResult | undefined\n}\n\nexport interface InfiniteQueryResult<TResult, TError = unknown>\n  extends QueryResultBase<TResult[], TError> {}\n\nexport interface MutateConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> {\n  onSuccess?: (data: TResult, variables: TVariables) => Promise<void> | void\n  onError?: (\n    error: TError,\n    variables: TVariables,\n    snapshotValue: TSnapshot\n  ) => Promise<void> | void\n  onSettled?: (\n    data: undefined | TResult,\n    error: TError | null,\n    variables: TVariables,\n    snapshotValue?: TSnapshot\n  ) => Promise<void> | void\n  throwOnError?: boolean\n}\n\nexport interface MutationConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutateConfig<TResult, TError, TVariables, TSnapshot> {\n  onMutate?: (variables: TVariables) => Promise<TSnapshot> | TSnapshot\n  useErrorBoundary?: boolean\n  suspense?: boolean\n  /**\n   * By default the query cache from the context is used, but a different cache can be specified.\n   */\n  queryCache?: QueryCache\n}\n\nexport type MutationFunction<TResult, TVariables = unknown> = (\n  variables: TVariables\n) => Promise<TResult>\n\nexport type MutateFunction<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> = (\n  variables?: TVariables,\n  config?: MutateConfig<TResult, TError, TVariables, TSnapshot>\n) => Promise<TResult | undefined>\n\nexport type MutationResultPair<TResult, TError, TVariables, TSnapshot> = [\n  MutateFunction<TResult, TError, TVariables, TSnapshot>,\n  MutationResult<TResult, TError>\n]\n\nexport interface MutationResult<TResult, TError = unknown> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n  reset: () => void\n}\n\nexport interface ReactQueryConfig<TResult = unknown, TError = unknown> {\n  queries?: ReactQueryQueriesConfig<TResult, TError>\n  shared?: ReactQuerySharedConfig\n  mutations?: ReactQueryMutationsConfig<TResult, TError>\n}\n\nexport interface ReactQuerySharedConfig {\n  suspense?: boolean\n}\n\nexport interface ReactQueryQueriesConfig<TResult, TError>\n  extends QueryObserverConfig<TResult, TError> {}\n\nexport interface ReactQueryMutationsConfig<\n  TResult,\n  TError = unknown,\n  TVariables = unknown,\n  TSnapshot = unknown\n> extends MutationConfig<TResult, TError, TVariables, TSnapshot> {}\n","import { QueryConfig, QueryStatus, QueryKey, QueryFunction } from './types'\n\n// TYPES\n\nexport type DataUpdateFunction<TInput, TOutput> = (input: TInput) => TOutput\n\nexport type Updater<TInput, TOutput> =\n  | TOutput\n  | DataUpdateFunction<TInput, TOutput>\n\ntype ConsoleFunction = (...args: any[]) => void\n\nexport interface ConsoleObject {\n  log: ConsoleFunction\n  warn: ConsoleFunction\n  error: ConsoleFunction\n}\n\ninterface Cancelable {\n  cancel(): void\n}\n\nexport class CancelledError {}\n\n// UTILS\n\nlet _uid = 0\nexport const uid = () => _uid++\n\nexport const isServer = typeof window === 'undefined'\n\nexport function noop(): void {\n  return void 0\n}\n\nexport let Console: ConsoleObject = console || {\n  error: noop,\n  warn: noop,\n  log: noop,\n}\n\nexport function setConsole(c: ConsoleObject) {\n  Console = c\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as DataUpdateFunction<TInput, TOutput>)(input)\n    : updater\n}\n\nfunction stableStringifyReplacer(_key: string, value: any): unknown {\n  if (typeof value === 'function') {\n    throw new Error('Cannot stringify non JSON value')\n  }\n\n  if (isObject(value)) {\n    return Object.keys(value)\n      .sort()\n      .reduce((result, key) => {\n        result[key] = value[key]\n        return result\n      }, {} as any)\n  }\n\n  return value\n}\n\nexport function stableStringify(value: any): string {\n  return JSON.stringify(value, stableStringifyReplacer)\n}\n\nexport function deepIncludes(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (typeof a === 'object') {\n    return !Object.keys(b).some(key => !deepIncludes(a[key], b[key]))\n  }\n\n  return false\n}\n\nexport function isDocumentVisible(): boolean {\n  // document global can be unavailable in react native\n  if (typeof document === 'undefined') {\n    return true\n  }\n  return [undefined, 'visible', 'prerender'].includes(document.visibilityState)\n}\n\nexport function isOnline(): boolean {\n  return navigator.onLine === undefined || navigator.onLine\n}\n\nexport function getQueryArgs<TResult, TError, TOptions = undefined>(\n  args: any[]\n): [QueryKey, QueryConfig<TResult, TError>, TOptions] {\n  let queryKey: QueryKey\n  let queryFn: QueryFunction<TResult> | undefined\n  let config: QueryConfig<TResult, TError> | undefined\n  let options: TOptions\n\n  if (isObject(args[0])) {\n    queryKey = args[0].queryKey\n    queryFn = args[0].queryFn\n    config = args[0].config\n    options = args[1]\n  } else if (isObject(args[1])) {\n    queryKey = args[0]\n    config = args[1]\n    options = args[2]\n  } else {\n    queryKey = args[0]\n    queryFn = args[1]\n    config = args[2]\n    options = args[3]\n  }\n\n  config = config ? { queryKey, ...config } : { queryKey }\n\n  if (queryFn) {\n    config = { ...config, queryFn }\n  }\n\n  return [queryKey, config, options]\n}\n\nexport function deepEqual(a: any, b: any): boolean {\n  return replaceEqualDeep(a, b) === a\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = Array.isArray(a) && Array.isArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\nexport function isObject(a: unknown): boolean {\n  return a && typeof a === 'object' && !Array.isArray(a)\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function isCancelable(value: any): value is Cancelable {\n  return typeof value?.cancel === 'function'\n}\n\nexport function isError(value: any): value is Error {\n  return value instanceof Error\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function getStatusProps<T extends QueryStatus>(status: T) {\n  return {\n    status,\n    isLoading: status === QueryStatus.Loading,\n    isSuccess: status === QueryStatus.Success,\n    isError: status === QueryStatus.Error,\n    isIdle: status === QueryStatus.Idle,\n  }\n}\n\nexport function createSetHandler(fn: () => void) {\n  let removePreviousHandler: (() => void) | void\n  return (callback: (handler: () => void) => void) => {\n    // Unsub the old handler\n    if (removePreviousHandler) {\n      removePreviousHandler()\n    }\n    // Sub the new handler\n    removePreviousHandler = callback(fn)\n  }\n}\n","import { stableStringify } from './utils'\nimport {\n  ArrayQueryKey,\n  QueryKey,\n  QueryKeySerializerFunction,\n  ReactQueryConfig,\n  QueryConfig,\n  MutationConfig,\n} from './types'\n\n// TYPES\n\nexport interface ReactQueryConfigRef {\n  current: ReactQueryConfig\n}\n\n// CONFIG\n\nexport const defaultQueryKeySerializerFn: QueryKeySerializerFunction = (\n  queryKey: QueryKey\n): [string, ArrayQueryKey] => {\n  try {\n    let arrayQueryKey: ArrayQueryKey = Array.isArray(queryKey)\n      ? queryKey\n      : [queryKey]\n    const queryHash = stableStringify(arrayQueryKey)\n    arrayQueryKey = JSON.parse(queryHash)\n    return [queryHash, arrayQueryKey]\n  } catch {\n    throw new Error('A valid query key is required!')\n  }\n}\n\n/**\n * Config merging strategy\n *\n * When using hooks the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the hook query cache.\n * 3. Combined defaults from any config providers in the tree.\n * 4. Query/mutation config provided to the hook.\n *\n * When using a query cache directly the config will be merged in the following order:\n *\n * 1. These defaults.\n * 2. Defaults from the query cache.\n * 3. Query/mutation config provided to the query cache method.\n */\nexport const DEFAULT_STALE_TIME = 0\nexport const DEFAULT_CACHE_TIME = 5 * 60 * 1000\nexport const DEFAULT_CONFIG: ReactQueryConfig = {\n  queries: {\n    cacheTime: DEFAULT_CACHE_TIME,\n    enabled: true,\n    notifyOnStatusChange: true,\n    queryKeySerializerFn: defaultQueryKeySerializerFn,\n    refetchOnMount: true,\n    refetchOnReconnect: true,\n    refetchOnWindowFocus: true,\n    retry: 3,\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),\n    staleTime: DEFAULT_STALE_TIME,\n    structuralSharing: true,\n  },\n}\n\nexport function mergeReactQueryConfigs(\n  a: ReactQueryConfig,\n  b: ReactQueryConfig\n): ReactQueryConfig {\n  return {\n    shared: {\n      ...a.shared,\n      ...b.shared,\n    },\n    queries: {\n      ...a.queries,\n      ...b.queries,\n    },\n    mutations: {\n      ...a.mutations,\n      ...b.mutations,\n    },\n  }\n}\n\nexport function getDefaultedQueryConfig<TResult, TError>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: QueryConfig<TResult, TError>,\n  configOverrides?: QueryConfig<TResult, TError>\n): QueryConfig<TResult, TError> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.queries,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.queries,\n    ...contextConfig?.shared,\n    ...contextConfig?.queries,\n    ...config,\n    ...configOverrides,\n  } as QueryConfig<TResult, TError>\n}\n\nexport function getDefaultedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  queryCacheConfig?: ReactQueryConfig,\n  contextConfig?: ReactQueryConfig,\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>,\n  configOverrides?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  return {\n    ...DEFAULT_CONFIG.shared,\n    ...DEFAULT_CONFIG.mutations,\n    ...queryCacheConfig?.shared,\n    ...queryCacheConfig?.mutations,\n    ...contextConfig?.shared,\n    ...contextConfig?.mutations,\n    ...config,\n    ...configOverrides,\n  } as MutationConfig<TResult, TError, TVariables, TSnapshot>\n}\n","import { getStatusProps, isServer, isDocumentVisible } from './utils'\nimport type { QueryResult, QueryObserverConfig } from './types'\nimport type { Query, Action, FetchMoreOptions, RefetchOptions } from './query'\nimport type { QueryCache } from './queryCache'\n\nexport type UpdateListener<TResult, TError> = (\n  result: QueryResult<TResult, TError>\n) => void\n\nexport class QueryObserver<TResult, TError> {\n  config: QueryObserverConfig<TResult, TError>\n\n  private queryCache: QueryCache\n  private currentQuery!: Query<TResult, TError>\n  private currentResult!: QueryResult<TResult, TError>\n  private previousQueryResult?: QueryResult<TResult, TError>\n  private updateListener?: UpdateListener<TResult, TError>\n  private initialFetchedCount: number\n  private staleTimeoutId?: number\n  private refetchIntervalId?: number\n  private started?: boolean\n\n  constructor(config: QueryObserverConfig<TResult, TError>) {\n    this.config = config\n    this.queryCache = config.queryCache!\n    this.initialFetchedCount = 0\n\n    // Bind exposed methods\n    this.clear = this.clear.bind(this)\n    this.refetch = this.refetch.bind(this)\n    this.fetchMore = this.fetchMore.bind(this)\n\n    // Subscribe to the query\n    this.updateQuery()\n  }\n\n  subscribe(listener?: UpdateListener<TResult, TError>): () => void {\n    this.started = true\n    this.updateListener = listener\n    this.currentQuery.subscribeObserver(this)\n\n    if (this.config.enabled && this.config.forceFetchOnMount) {\n      this.fetch()\n    } else {\n      this.optionalFetch()\n    }\n\n    this.updateTimers()\n    return this.unsubscribe.bind(this)\n  }\n\n  unsubscribe(): void {\n    this.started = false\n    this.updateListener = undefined\n    this.clearTimers()\n    this.currentQuery.unsubscribeObserver(this)\n  }\n\n  updateConfig(config: QueryObserverConfig<TResult, TError>): void {\n    const prevConfig = this.config\n    this.config = config\n\n    const updated = this.updateQuery()\n\n    // Take no further actions if the observer did not start yet\n    if (!this.started) {\n      return\n    }\n\n    // If we subscribed to a new query, optionally fetch and update refetch\n    if (updated) {\n      this.optionalFetch()\n      this.updateTimers()\n      return\n    }\n\n    // Optionally fetch if the query became enabled\n    if (config.enabled && !prevConfig.enabled) {\n      this.optionalFetch()\n    }\n\n    // Update stale interval if needed\n    if (\n      config.enabled !== prevConfig.enabled ||\n      config.staleTime !== prevConfig.staleTime\n    ) {\n      this.updateStaleTimeout()\n    }\n\n    // Update refetch interval if needed\n    if (\n      config.enabled !== prevConfig.enabled ||\n      config.refetchInterval !== prevConfig.refetchInterval ||\n      config.refetchIntervalInBackground !==\n        prevConfig.refetchIntervalInBackground\n    ) {\n      this.updateRefetchInterval()\n    }\n  }\n\n  isStale(): boolean {\n    return this.currentResult.isStale\n  }\n\n  getCurrentQuery(): Query<TResult, TError> {\n    return this.currentQuery\n  }\n\n  getCurrentResult(): QueryResult<TResult, TError> {\n    return this.currentResult\n  }\n\n  clear(): void {\n    return this.currentQuery.clear()\n  }\n\n  async refetch(options?: RefetchOptions): Promise<TResult | undefined> {\n    return this.currentQuery.refetch(options, this.config)\n  }\n\n  async fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions\n  ): Promise<TResult | undefined> {\n    return this.currentQuery.fetchMore(fetchMoreVariable, options, this.config)\n  }\n\n  async fetch(): Promise<TResult | undefined> {\n    try {\n      return await this.currentQuery.fetch(undefined, this.config)\n    } catch {\n      // ignore\n    }\n  }\n\n  private optionalFetch(): void {\n    if (\n      this.config.enabled && // Don't auto refetch if disabled\n      !(this.config.suspense && this.currentResult.isFetched) && // Don't refetch if in suspense mode and the data is already fetched\n      this.currentResult.isStale && // Only refetch if stale\n      (this.config.refetchOnMount || this.currentQuery.observers.length === 1)\n    ) {\n      this.fetch()\n    }\n  }\n\n  private updateIsStale(): void {\n    const isStale = this.currentQuery.isStaleByTime(this.config.staleTime)\n    if (isStale !== this.currentResult.isStale) {\n      this.updateResult()\n      this.notify()\n    }\n  }\n\n  private notify(): void {\n    this.updateListener?.(this.currentResult)\n  }\n\n  private updateStaleTimeout(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearStaleTimeout()\n\n    const staleTime = this.config.staleTime || 0\n    const { isStale, updatedAt } = this.currentResult\n\n    if (isStale || staleTime === Infinity) {\n      return\n    }\n\n    const timeElapsed = Date.now() - updatedAt\n    const timeUntilStale = staleTime - timeElapsed\n    const timeout = Math.max(timeUntilStale, 0)\n\n    this.staleTimeoutId = setTimeout(() => {\n      this.updateIsStale()\n    }, timeout)\n  }\n\n  private updateRefetchInterval(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearRefetchInterval()\n\n    if (\n      !this.config.enabled ||\n      !this.config.refetchInterval ||\n      this.config.refetchInterval < 0 ||\n      this.config.refetchInterval === Infinity\n    ) {\n      return\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.config.refetchIntervalInBackground || isDocumentVisible()) {\n        this.fetch()\n      }\n    }, this.config.refetchInterval)\n  }\n\n  updateTimers(): void {\n    this.updateStaleTimeout()\n    this.updateRefetchInterval()\n  }\n\n  clearTimers(): void {\n    this.clearStaleTimeout()\n    this.clearRefetchInterval()\n  }\n\n  private clearStaleTimeout(): void {\n    if (this.staleTimeoutId) {\n      clearInterval(this.staleTimeoutId)\n      this.staleTimeoutId = undefined\n    }\n  }\n\n  private clearRefetchInterval(): void {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId)\n      this.refetchIntervalId = undefined\n    }\n  }\n\n  private updateResult(): void {\n    const { currentQuery, currentResult, previousQueryResult, config } = this\n    const { state } = currentQuery\n    let { data, status, updatedAt } = state\n    let isPreviousData = false\n\n    // Keep previous data if needed\n    if (\n      config.keepPreviousData &&\n      (state.isIdle || state.isLoading) &&\n      previousQueryResult?.isSuccess\n    ) {\n      data = previousQueryResult.data\n      updatedAt = previousQueryResult.updatedAt\n      status = previousQueryResult.status\n      isPreviousData = true\n    }\n\n    let isStale = false\n\n    // When the query has not been fetched yet and this is the initial render,\n    // determine the staleness based on the initialStale or existence of initial data.\n    if (!currentResult && !state.isFetched) {\n      if (typeof config.initialStale === 'function') {\n        isStale = config.initialStale()\n      } else if (typeof config.initialStale === 'boolean') {\n        isStale = config.initialStale\n      } else {\n        isStale = typeof state.data === 'undefined'\n      }\n    } else {\n      isStale = currentQuery.isStaleByTime(config.staleTime)\n    }\n\n    this.currentResult = {\n      ...getStatusProps(status),\n      canFetchMore: state.canFetchMore,\n      clear: this.clear,\n      data,\n      error: state.error,\n      failureCount: state.failureCount,\n      fetchMore: this.fetchMore,\n      isFetched: state.isFetched,\n      isFetchedAfterMount: state.fetchedCount > this.initialFetchedCount,\n      isFetching: state.isFetching,\n      isFetchingMore: state.isFetchingMore,\n      isPreviousData,\n      isStale,\n      refetch: this.refetch,\n      updatedAt,\n    }\n  }\n\n  private updateQuery(): boolean {\n    const prevQuery = this.currentQuery\n\n    // Remove the initial data when there is an existing query\n    // because this data should not be used for a new query\n    const config =\n      this.config.keepPreviousData && prevQuery\n        ? { ...this.config, initialData: undefined }\n        : this.config\n\n    const newQuery = this.queryCache.buildQuery(config.queryKey, config)\n\n    if (newQuery === prevQuery) {\n      return false\n    }\n\n    this.previousQueryResult = this.currentResult\n    this.currentQuery = newQuery\n    this.initialFetchedCount = newQuery.state.fetchedCount\n    this.updateResult()\n\n    if (this.started) {\n      prevQuery?.unsubscribeObserver(this)\n      this.currentQuery.subscribeObserver(this)\n    }\n\n    return true\n  }\n\n  onQueryUpdate(action: Action<TResult, TError>): void {\n    // Store current result and get new result\n    const prevResult = this.currentResult\n    this.updateResult()\n\n    const { currentResult, config } = this\n\n    // We need to check the action because the state could have\n    // transitioned from success to success in case of `setQueryData`.\n    if (action.type === 'Success' && currentResult.isSuccess) {\n      config.onSuccess?.(currentResult.data!)\n      config.onSettled?.(currentResult.data!, null)\n      this.updateTimers()\n    } else if (action.type === 'Error' && currentResult.isError) {\n      config.onError?.(currentResult.error!)\n      config.onSettled?.(undefined, currentResult.error!)\n      this.updateTimers()\n    }\n\n    if (\n      // Always notify on data or error change\n      currentResult.data !== prevResult.data ||\n      currentResult.error !== prevResult.error ||\n      // Maybe notify on other changes\n      config.notifyOnStatusChange\n    ) {\n      this.notify()\n    }\n  }\n}\n","import {\n  CancelledError,\n  Console,\n  Updater,\n  functionalUpdate,\n  getStatusProps,\n  isCancelable,\n  isCancelledError,\n  isDocumentVisible,\n  isOnline,\n  isServer,\n  noop,\n  replaceEqualDeep,\n  sleep,\n} from './utils'\nimport {\n  ArrayQueryKey,\n  InitialDataFunction,\n  IsFetchingMoreValue,\n  QueryConfig,\n  QueryFunction,\n  QueryStatus,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport { QueryObserver, UpdateListener } from './queryObserver'\n\n// TYPES\n\ninterface QueryInitConfig<TResult, TError> {\n  queryCache: QueryCache\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  notifyGlobalListeners: (query: Query<TResult, TError>) => void\n}\n\nexport interface QueryState<TResult, TError> {\n  canFetchMore?: boolean\n  data?: TResult\n  error: TError | null\n  failureCount: number\n  fetchedCount: number\n  isError: boolean\n  isFetched: boolean\n  isFetching: boolean\n  isFetchingMore: IsFetchingMoreValue\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  status: QueryStatus\n  throwInErrorBoundary?: boolean\n  updatedAt: number\n}\n\ninterface FetchOptions {\n  fetchMore?: FetchMoreOptions\n}\n\nexport interface FetchMoreOptions {\n  fetchMoreVariable?: unknown\n  previous: boolean\n}\n\nexport interface RefetchOptions {\n  throwOnError?: boolean\n}\n\nexport enum ActionType {\n  Failed = 'Failed',\n  Fetch = 'Fetch',\n  Success = 'Success',\n  Error = 'Error',\n}\n\ninterface FailedAction {\n  type: ActionType.Failed\n}\n\ninterface FetchAction {\n  type: ActionType.Fetch\n  isFetchingMore?: IsFetchingMoreValue\n}\n\ninterface SuccessAction<TResult> {\n  type: ActionType.Success\n  data: TResult | undefined\n  canFetchMore?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: ActionType.Error\n  error: TError\n}\n\nexport type Action<TResult, TError> =\n  | ErrorAction<TError>\n  | FailedAction\n  | FetchAction\n  | SuccessAction<TResult>\n\n// CLASS\n\nexport class Query<TResult, TError> {\n  queryKey: ArrayQueryKey\n  queryHash: string\n  config: QueryConfig<TResult, TError>\n  observers: QueryObserver<TResult, TError>[]\n  state: QueryState<TResult, TError>\n  cacheTime: number\n\n  private queryCache: QueryCache\n  private promise?: Promise<TResult | undefined>\n  private gcTimeout?: number\n  private cancelFetch?: () => void\n  private continueFetch?: () => void\n  private isTransportCancelable?: boolean\n  private notifyGlobalListeners: (query: Query<TResult, TError>) => void\n\n  constructor(init: QueryInitConfig<TResult, TError>) {\n    this.config = init.config\n    this.queryCache = init.queryCache\n    this.queryKey = init.queryKey\n    this.queryHash = init.queryHash\n    this.notifyGlobalListeners = init.notifyGlobalListeners\n    this.observers = []\n    this.state = getDefaultState(init.config)\n    this.cacheTime = init.config.cacheTime!\n    this.scheduleGc()\n  }\n\n  private updateConfig(config: QueryConfig<TResult, TError>): void {\n    this.config = config\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime || 0)\n  }\n\n  private dispatch(action: Action<TResult, TError>): void {\n    this.state = queryReducer(this.state, action)\n\n    this.observers.forEach(observer => {\n      observer.onQueryUpdate(action)\n    })\n\n    this.notifyGlobalListeners(this)\n  }\n\n  private scheduleGc(): void {\n    if (isServer) {\n      return\n    }\n\n    this.clearGcTimeout()\n\n    if (this.cacheTime === Infinity || this.observers.length > 0) {\n      return\n    }\n\n    this.gcTimeout = setTimeout(() => {\n      this.clear()\n    }, this.cacheTime)\n  }\n\n  cancel(): void {\n    this.cancelFetch?.()\n  }\n\n  private continue(): void {\n    this.continueFetch?.()\n  }\n\n  private clearTimersObservers(): void {\n    this.observers.forEach(observer => {\n      observer.clearTimers()\n    })\n  }\n\n  private clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout)\n      this.gcTimeout = undefined\n    }\n  }\n\n  setData(updater: Updater<TResult | undefined, TResult>): void {\n    const prevData = this.state.data\n\n    // Get the new data\n    let data: TResult | undefined = functionalUpdate(updater, prevData)\n\n    // Structurally share data between prev and new data if needed\n    if (this.config.structuralSharing) {\n      data = replaceEqualDeep(prevData, data)\n    }\n\n    // Use prev data if an isDataEqual function is defined and returns `true`\n    if (this.config.isDataEqual?.(prevData, data)) {\n      data = prevData\n    }\n\n    // Try to determine if more data can be fetched\n    const canFetchMore = hasMorePages(this.config, data)\n\n    // Set data and mark it as cached\n    this.dispatch({\n      type: ActionType.Success,\n      data,\n      canFetchMore,\n    })\n  }\n\n  clear(): void {\n    this.queryCache.removeQuery(this)\n  }\n\n  destroy(): void {\n    this.clearGcTimeout()\n    this.clearTimersObservers()\n    this.cancel()\n  }\n\n  isEnabled(): boolean {\n    return this.observers.some(observer => observer.config.enabled)\n  }\n\n  isStale(): boolean {\n    return this.observers.some(observer => observer.isStale())\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      !this.state.isSuccess || this.state.updatedAt + staleTime <= Date.now()\n    )\n  }\n\n  onInteraction(type: 'focus' | 'online'): void {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    const observer = this.observers.find(\n      observer =>\n        observer.isStale() &&\n        observer.config.enabled &&\n        ((observer.config.refetchOnWindowFocus && type === 'focus') ||\n          (observer.config.refetchOnReconnect && type === 'online'))\n    )\n\n    if (observer) {\n      observer.fetch().catch(noop)\n    }\n\n    // Continue any paused fetch\n    this.continue()\n  }\n\n  subscribe(\n    listener?: UpdateListener<TResult, TError>\n  ): QueryObserver<TResult, TError> {\n    const observer = new QueryObserver<TResult, TError>({\n      queryCache: this.queryCache,\n      queryKey: this.queryKey,\n      ...this.config,\n    })\n\n    observer.subscribe(listener)\n\n    return observer\n  }\n\n  subscribeObserver(observer: QueryObserver<TResult, TError>): void {\n    this.observers.push(observer)\n\n    // Stop the query from being garbage collected\n    this.clearGcTimeout()\n  }\n\n  unsubscribeObserver(observer: QueryObserver<TResult, TError>): void {\n    this.observers = this.observers.filter(x => x !== observer)\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel()\n      }\n    }\n\n    this.scheduleGc()\n  }\n\n  async refetch(\n    options?: RefetchOptions,\n    config?: QueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    try {\n      return await this.fetch(undefined, config)\n    } catch (error) {\n      if (options?.throwOnError === true) {\n        throw error\n      }\n    }\n  }\n\n  async fetchMore(\n    fetchMoreVariable?: unknown,\n    options?: FetchMoreOptions,\n    config?: QueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    return this.fetch(\n      {\n        fetchMore: {\n          fetchMoreVariable,\n          previous: options?.previous || false,\n        },\n      },\n      config\n    )\n  }\n\n  async fetch(\n    options?: FetchOptions,\n    config?: QueryConfig<TResult, TError>\n  ): Promise<TResult | undefined> {\n    // If we are already fetching, return current promise\n    if (this.promise) {\n      return this.promise\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (config) {\n      this.updateConfig(config)\n    }\n\n    config = this.config\n\n    // Check if there is a query function\n    if (typeof config.queryFn !== 'function') {\n      return\n    }\n\n    // Get the query function params\n    const filter = config.queryFnParamsFilter\n    const params = filter ? filter(this.queryKey) : this.queryKey\n\n    this.promise = (async () => {\n      try {\n        let data: any\n\n        if (config.infinite) {\n          data = await this.startInfiniteFetch(config, params, options)\n        } else {\n          data = await this.startFetch(config, params, options)\n        }\n\n        // Set success state\n        this.setData(data)\n\n        // Cleanup\n        delete this.promise\n\n        // Return data\n        return data\n      } catch (error) {\n        // Set error state\n        this.dispatch({\n          type: ActionType.Error,\n          error,\n        })\n\n        // Log error\n        if (!isCancelledError(error)) {\n          Console.error(error)\n        }\n\n        // Cleanup\n        delete this.promise\n\n        // Propagate error\n        throw error\n      }\n    })()\n\n    return this.promise\n  }\n\n  private async startFetch(\n    config: QueryConfig<TResult, TError>,\n    params: unknown[],\n    _options?: FetchOptions\n  ): Promise<TResult> {\n    // Create function to fetch the data\n    const fetchData = () => config.queryFn!(...params)\n\n    // Set to fetching state if not already in it\n    if (!this.state.isFetching) {\n      this.dispatch({ type: ActionType.Fetch })\n    }\n\n    // Try to fetch the data\n    return this.tryFetchData(config, fetchData)\n  }\n\n  private async startInfiniteFetch(\n    config: QueryConfig<TResult, TError>,\n    params: unknown[],\n    options?: FetchOptions\n  ): Promise<TResult[]> {\n    const fetchMore = options?.fetchMore\n    const { previous, fetchMoreVariable } = fetchMore || {}\n    const isFetchingMore = fetchMore ? (previous ? 'previous' : 'next') : false\n    const prevPages: TResult[] = (this.state.data as any) || []\n\n    // Create function to fetch a page\n    const fetchPage = async (\n      pages: TResult[],\n      prepend?: boolean,\n      cursor?: unknown\n    ) => {\n      const lastPage = getLastPage(pages, prepend)\n\n      if (\n        typeof cursor === 'undefined' &&\n        typeof lastPage !== 'undefined' &&\n        config.getFetchMore\n      ) {\n        cursor = config.getFetchMore(lastPage, pages)\n      }\n\n      const page = await config.queryFn!(...params, cursor)\n\n      return prepend ? [page, ...pages] : [...pages, page]\n    }\n\n    // Create function to fetch the data\n    const fetchData = () => {\n      if (isFetchingMore) {\n        return fetchPage(prevPages, previous, fetchMoreVariable)\n      } else if (!prevPages.length) {\n        return fetchPage([])\n      } else {\n        let promise = fetchPage([])\n        for (let i = 1; i < prevPages.length; i++) {\n          promise = promise.then(fetchPage)\n        }\n        return promise\n      }\n    }\n\n    // Set to fetching state if not already in it\n    if (!this.state.isFetching) {\n      this.dispatch({ type: ActionType.Fetch, isFetchingMore })\n    }\n\n    // Try to get the data\n    return this.tryFetchData(config, fetchData)\n  }\n\n  private async tryFetchData<T>(\n    config: QueryConfig<TResult, TError>,\n    fn: QueryFunction<T>\n  ): Promise<T> {\n    return new Promise<T>((outerResolve, outerReject) => {\n      let resolved = false\n      let continueLoop: () => void\n      let cancelTransport: () => void\n\n      const done = () => {\n        resolved = true\n\n        delete this.cancelFetch\n        delete this.continueFetch\n        delete this.isTransportCancelable\n\n        // End loop if currently paused\n        continueLoop?.()\n      }\n\n      const resolve = (value: any) => {\n        done()\n        outerResolve(value)\n      }\n\n      const reject = (value: any) => {\n        done()\n        outerReject(value)\n      }\n\n      // Create callback to cancel this fetch\n      this.cancelFetch = () => {\n        reject(new CancelledError())\n        try {\n          cancelTransport?.()\n        } catch {}\n      }\n\n      // Create callback to continue this fetch\n      this.continueFetch = () => {\n        continueLoop?.()\n      }\n\n      // Create loop function\n      const run = async () => {\n        try {\n          // Execute query\n          const promiseOrValue = fn()\n\n          // Check if the transport layer support cancellation\n          if (isCancelable(promiseOrValue)) {\n            cancelTransport = () => {\n              promiseOrValue.cancel()\n            }\n            this.isTransportCancelable = true\n          }\n\n          // Await data\n          resolve(await promiseOrValue)\n        } catch (error) {\n          // Stop if the fetch is already resolved\n          if (resolved) {\n            return\n          }\n\n          // Do we need to retry the request?\n          const { failureCount } = this.state\n          const { retry, retryDelay } = config\n\n          const shouldRetry =\n            retry === true ||\n            failureCount < retry! ||\n            (typeof retry === 'function' && retry(failureCount, error))\n\n          if (!shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error)\n            return\n          }\n\n          // Increase the failureCount\n          this.dispatch({ type: ActionType.Failed })\n\n          // Delay\n          await sleep(functionalUpdate(retryDelay, failureCount) || 0)\n\n          // Pause retry if the document is not visible or when the device is offline\n          if (!isDocumentVisible() || !isOnline()) {\n            await new Promise(continueResolve => {\n              continueLoop = continueResolve\n            })\n          }\n\n          // Try again if not resolved yet\n          if (!resolved) {\n            run()\n          }\n        }\n      }\n\n      // Start loop\n      run()\n    })\n  }\n}\n\nfunction getLastPage<TResult>(pages: TResult[], previous?: boolean): TResult {\n  return previous ? pages[0] : pages[pages.length - 1]\n}\n\nfunction hasMorePages<TResult, TError>(\n  config: QueryConfig<TResult, TError>,\n  pages: unknown,\n  previous?: boolean\n): boolean | undefined {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages))\n  }\n}\n\nfunction getDefaultState<TResult, TError>(\n  config: QueryConfig<TResult, TError>\n): QueryState<TResult, TError> {\n  const initialData =\n    typeof config.initialData === 'function'\n      ? (config.initialData as InitialDataFunction<TResult>)()\n      : config.initialData\n\n  const hasInitialData = typeof initialData !== 'undefined'\n\n  const initialStatus = hasInitialData\n    ? QueryStatus.Success\n    : config.enabled\n    ? QueryStatus.Loading\n    : QueryStatus.Idle\n\n  return {\n    ...getStatusProps(initialStatus),\n    error: null,\n    isFetched: false,\n    isFetching: initialStatus === QueryStatus.Loading,\n    isFetchingMore: false,\n    failureCount: 0,\n    fetchedCount: 0,\n    data: initialData,\n    updatedAt: Date.now(),\n    canFetchMore: hasMorePages(config, initialData),\n  }\n}\n\nexport function queryReducer<TResult, TError>(\n  state: QueryState<TResult, TError>,\n  action: Action<TResult, TError>\n): QueryState<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Failed:\n      return {\n        ...state,\n        failureCount: state.failureCount + 1,\n      }\n    case ActionType.Fetch:\n      const status =\n        typeof state.data !== 'undefined'\n          ? QueryStatus.Success\n          : QueryStatus.Loading\n      return {\n        ...state,\n        ...getStatusProps(status),\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        failureCount: 0,\n      }\n    case ActionType.Success:\n      return {\n        ...state,\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n        fetchedCount: state.fetchedCount + 1,\n        isFetched: true,\n        isFetching: false,\n        isFetchingMore: false,\n        canFetchMore: action.canFetchMore,\n        updatedAt: Date.now(),\n        failureCount: 0,\n      }\n    case ActionType.Error:\n      return {\n        ...state,\n        ...getStatusProps(QueryStatus.Error),\n        error: action.error,\n        fetchedCount: state.fetchedCount + 1,\n        isFetched: true,\n        isFetching: false,\n        isFetchingMore: false,\n        failureCount: state.failureCount + 1,\n        throwInErrorBoundary: true,\n      }\n    default:\n      return state\n  }\n}\n","import {\n  Updater,\n  deepIncludes,\n  functionalUpdate,\n  getQueryArgs,\n  isDocumentVisible,\n  isObject,\n  isOnline,\n  isServer,\n} from './utils'\nimport { getDefaultedQueryConfig } from './config'\nimport { Query } from './query'\nimport {\n  QueryConfig,\n  QueryFunction,\n  QueryKey,\n  ReactQueryConfig,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from './types'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  frozen?: boolean\n  defaultConfig?: ReactQueryConfig\n}\n\ninterface ClearOptions {\n  notify?: boolean\n}\n\ninterface PrefetchQueryOptions {\n  force?: boolean\n  throwOnError?: boolean\n}\n\ninterface InvalidateQueriesOptions extends QueryPredicateOptions {\n  refetchActive?: boolean\n  refetchInactive?: boolean\n  throwOnError?: boolean\n}\n\ninterface QueryPredicateOptions {\n  exact?: boolean\n}\n\ntype QueryPredicate = QueryKey | QueryPredicateFn | true\n\ntype QueryPredicateFn = (query: Query<unknown, unknown>) => boolean\n\nexport interface PrefetchQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n  options?: PrefetchQueryOptions\n}\n\ninterface QueryHashMap {\n  [hash: string]: Query<any, any>\n}\n\ntype QueryCacheListener = (\n  cache: QueryCache,\n  query?: Query<unknown, unknown>\n) => void\n\n// CLASS\n\nexport class QueryCache {\n  isFetching: number\n\n  private config: QueryCacheConfig\n  private globalListeners: QueryCacheListener[]\n  private queries: QueryHashMap\n  private queriesArray: Query<any, any>[]\n\n  constructor(config?: QueryCacheConfig) {\n    this.config = config || {}\n\n    // A frozen cache does not add new queries to the cache\n    this.globalListeners = []\n\n    this.queries = {}\n    this.queriesArray = []\n    this.isFetching = 0\n  }\n\n  private notifyGlobalListeners(query?: Query<any, any>) {\n    this.isFetching = this.getQueries().reduce(\n      (acc, query) => (query.state.isFetching ? acc + 1 : acc),\n      0\n    )\n\n    this.globalListeners.forEach(listener => {\n      listener(this, query)\n    })\n  }\n\n  getDefaultConfig() {\n    return this.config.defaultConfig\n  }\n\n  getDefaultedQueryConfig<TResult, TError>(\n    config?: QueryConfig<TResult, TError>\n  ): QueryConfig<TResult, TError> {\n    return getDefaultedQueryConfig(this.getDefaultConfig(), undefined, config, {\n      queryCache: this,\n    })\n  }\n\n  subscribe(listener: QueryCacheListener): () => void {\n    this.globalListeners.push(listener)\n    return () => {\n      this.globalListeners = this.globalListeners.filter(x => x !== listener)\n    }\n  }\n\n  clear(options?: ClearOptions): void {\n    this.removeQueries()\n    if (options?.notify) {\n      this.notifyGlobalListeners()\n    }\n  }\n\n  getQueries<TResult = unknown, TError = unknown>(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): Query<TResult, TError>[] {\n    if (predicate === true || typeof predicate === 'undefined') {\n      return this.queriesArray\n    }\n\n    let predicateFn: QueryPredicateFn\n\n    if (typeof predicate === 'function') {\n      predicateFn = predicate as QueryPredicateFn\n    } else {\n      const config = this.getDefaultedQueryConfig()\n      const [queryHash, queryKey] = config.queryKeySerializerFn!(predicate)\n\n      predicateFn = d =>\n        options?.exact\n          ? d.queryHash === queryHash\n          : deepIncludes(d.queryKey, queryKey)\n    }\n\n    return this.queriesArray.filter(predicateFn)\n  }\n\n  getQuery<TResult, TError = unknown>(\n    predicate: QueryPredicate\n  ): Query<TResult, TError> | undefined {\n    return this.getQueries<TResult, TError>(predicate, { exact: true })[0]\n  }\n\n  getQueryData<TResult>(predicate: QueryPredicate): TResult | undefined {\n    return this.getQuery<TResult>(predicate)?.state.data\n  }\n\n  removeQuery(query: Query<any, any>): void {\n    if (this.queries[query.queryHash]) {\n      query.destroy()\n      delete this.queries[query.queryHash]\n      this.queriesArray = this.queriesArray.filter(x => x !== query)\n      this.notifyGlobalListeners(query)\n    }\n  }\n\n  removeQueries(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => {\n      this.removeQuery(query)\n    })\n  }\n\n  cancelQueries(\n    predicate?: QueryPredicate,\n    options?: QueryPredicateOptions\n  ): void {\n    this.getQueries(predicate, options).forEach(query => {\n      query.cancel()\n    })\n  }\n\n  async invalidateQueries(\n    predicate?: QueryPredicate,\n    options?: InvalidateQueriesOptions\n  ): Promise<void> {\n    const { refetchActive = true, refetchInactive = false, throwOnError } =\n      options || {}\n\n    try {\n      await Promise.all(\n        this.getQueries(predicate, options).map(query => {\n          const enabled = query.isEnabled()\n\n          if ((enabled && refetchActive) || (!enabled && refetchInactive)) {\n            return query.fetch()\n          }\n\n          return undefined\n        })\n      )\n    } catch (err) {\n      if (throwOnError) {\n        throw err\n      }\n    }\n  }\n\n  resetErrorBoundaries(): void {\n    this.getQueries().forEach(query => {\n      query.state.throwInErrorBoundary = false\n    })\n  }\n\n  buildQuery<TResult, TError = unknown>(\n    userQueryKey: QueryKey,\n    queryConfig?: QueryConfig<TResult, TError>\n  ): Query<TResult, TError> {\n    const config = this.getDefaultedQueryConfig(queryConfig)\n    const [queryHash, queryKey] = config.queryKeySerializerFn!(userQueryKey)\n\n    if (this.queries[queryHash]) {\n      return this.queries[queryHash] as Query<TResult, TError>\n    }\n\n    const query = new Query<TResult, TError>({\n      queryCache: this,\n      queryKey,\n      queryHash,\n      config,\n      notifyGlobalListeners: query => {\n        this.notifyGlobalListeners(query)\n      },\n    })\n\n    if (!this.config.frozen) {\n      this.queries[queryHash] = query\n      this.queriesArray.push(query)\n      this.notifyGlobalListeners(query)\n    }\n\n    return query\n  }\n\n  // Parameter syntax with optional prefetch options\n  async prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function and optional prefetch options\n  async prefetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Parameter syntax with query function, config and optional prefetch options\n  async prefetchQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n    queryKey: QueryKey,\n    queryFn: TypedQueryFunction<TResult, TArgs>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  async prefetchQuery<TResult = unknown, TError = unknown>(\n    queryKey: QueryKey,\n    queryFn: QueryFunction<TResult>,\n    queryConfig: QueryConfig<TResult, TError>,\n    options?: PrefetchQueryOptions\n  ): Promise<TResult | undefined>\n\n  // Object syntax\n  async prefetchQuery<TResult = unknown, TError = unknown>(\n    config: PrefetchQueryObjectConfig<TResult, TError>\n  ): Promise<TResult | undefined>\n\n  // Implementation\n  async prefetchQuery<TResult, TError>(\n    ...args: any[]\n  ): Promise<TResult | undefined> {\n    if (\n      isObject(args[1]) &&\n      (args[1].hasOwnProperty('throwOnError') ||\n        args[1].hasOwnProperty('force'))\n    ) {\n      args[3] = args[1]\n      args[1] = undefined\n      args[2] = undefined\n    }\n\n    const [queryKey, config, options] = getQueryArgs<\n      TResult,\n      TError,\n      PrefetchQueryOptions | undefined\n    >(args)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    const configWithoutRetry = this.getDefaultedQueryConfig({\n      retry: false,\n      ...config,\n    })\n\n    let query\n    try {\n      query = this.buildQuery<TResult, TError>(queryKey, configWithoutRetry)\n      if (options?.force || query.isStaleByTime(config.staleTime)) {\n        await query.fetch(undefined, configWithoutRetry)\n      }\n      return query.state.data\n    } catch (error) {\n      if (options?.throwOnError) {\n        throw error\n      }\n    }\n  }\n\n  setQueryData<TResult, TError = unknown>(\n    queryKey: QueryKey,\n    updater: Updater<TResult | undefined, TResult>,\n    config?: QueryConfig<TResult, TError>\n  ) {\n    const query = this.getQuery<TResult, TError>(queryKey)\n\n    if (query) {\n      query.setData(updater)\n      return\n    }\n\n    this.buildQuery<TResult, TError>(queryKey, {\n      initialStale: typeof config?.staleTime === 'undefined',\n      initialData: functionalUpdate(updater, undefined),\n      ...config,\n    })\n  }\n}\n\nconst defaultQueryCache = makeQueryCache({ frozen: isServer })\nexport { defaultQueryCache as queryCache }\nexport const queryCaches = [defaultQueryCache]\n\nexport function makeQueryCache(config?: QueryCacheConfig) {\n  return new QueryCache(config)\n}\n\nexport function onVisibilityOrOnlineChange(type: 'focus' | 'online') {\n  if (isDocumentVisible() && isOnline()) {\n    queryCaches.forEach(queryCache => {\n      queryCache.getQueries().forEach(query => {\n        query.onInteraction(type)\n      })\n    })\n  }\n}\n","import { createSetHandler, isServer } from './utils'\nimport { onVisibilityOrOnlineChange } from './queryCache'\n\nexport const setFocusHandler = createSetHandler(() =>\n  onVisibilityOrOnlineChange('focus')\n)\n\nsetFocusHandler(handleFocus => {\n  if (isServer || !window?.addEventListener) {\n    return\n  }\n\n  // Listen to visibillitychange and focus\n  window.addEventListener('visibilitychange', handleFocus, false)\n  window.addEventListener('focus', handleFocus, false)\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('visibilitychange', handleFocus)\n    window.removeEventListener('focus', handleFocus)\n  }\n})\n","import { createSetHandler, isServer } from './utils'\nimport { onVisibilityOrOnlineChange } from './queryCache'\n\nexport const setOnlineHandler = createSetHandler(() =>\n  onVisibilityOrOnlineChange('online')\n)\n\nsetOnlineHandler(handleOnline => {\n  if (isServer || !window?.addEventListener) {\n    return\n  }\n\n  // Listen to online\n  window.addEventListener('online', handleOnline, false)\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('online', handleOnline)\n  }\n})\n","import React from 'react'\n\nimport {\n  queryCache as defaultQueryCache,\n  queryCaches,\n  makeQueryCache,\n} from '../core'\nimport { QueryCache } from '../core/queryCache'\n\nexport const queryCacheContext = React.createContext(defaultQueryCache)\n\nexport const useQueryCache = () => React.useContext(queryCacheContext)\n\nexport interface ReactQueryCacheProviderProps {\n  queryCache?: QueryCache\n}\n\nexport const ReactQueryCacheProvider: React.FC<ReactQueryCacheProviderProps> = ({\n  queryCache,\n  children,\n}) => {\n  const resolvedQueryCache = React.useMemo(\n    () => queryCache || makeQueryCache(),\n    [queryCache]\n  )\n\n  React.useEffect(() => {\n    queryCaches.push(resolvedQueryCache)\n\n    return () => {\n      // remove the cache from the active list\n      const i = queryCaches.indexOf(resolvedQueryCache)\n      if (i > -1) {\n        queryCaches.splice(i, 1)\n      }\n      // if the resolvedQueryCache was created by us, we need to tear it down\n      if (queryCache == null) {\n        resolvedQueryCache.clear({ notify: false })\n      }\n    }\n  }, [resolvedQueryCache, queryCache])\n\n  return (\n    <queryCacheContext.Provider value={resolvedQueryCache}>\n      {children}\n    </queryCacheContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { mergeReactQueryConfigs } from '../core/config'\nimport { ReactQueryConfig } from '../core/types'\n\nconst configContext = React.createContext<ReactQueryConfig | undefined>(\n  undefined\n)\n\nexport function useContextConfig() {\n  return React.useContext(configContext)\n}\n\nexport interface ReactQueryConfigProviderProps {\n  config: ReactQueryConfig\n}\n\nexport const ReactQueryConfigProvider: React.FC<ReactQueryConfigProviderProps> = ({\n  config,\n  children,\n}) => {\n  const parentConfig = useContextConfig()\n\n  const mergedConfig = React.useMemo(\n    () =>\n      parentConfig ? mergeReactQueryConfigs(parentConfig, config) : config,\n    [config, parentConfig]\n  )\n\n  return (\n    <configContext.Provider value={mergedConfig}>\n      {children}\n    </configContext.Provider>\n  )\n}\n","import React from 'react'\n\nimport { isServer } from '../core/utils'\n\nexport function useGetLatest<T>(obj: T): () => T {\n  const ref = React.useRef<T>(obj)\n  ref.current = obj\n  return React.useCallback(() => ref.current, [])\n}\n\nfunction useIsMounted(): () => boolean {\n  const mountedRef = React.useRef(false)\n  const isMounted = React.useCallback(() => mountedRef.current, [])\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mountedRef.current = true\n    return () => {\n      mountedRef.current = false\n    }\n  }, [])\n\n  return isMounted\n}\n\nexport function useMountedCallback<T extends Function>(callback: T): T {\n  const isMounted = useIsMounted()\n  return (React.useCallback(\n    (...args: any[]) => {\n      if (isMounted()) {\n        return callback(...args)\n      }\n    },\n    [callback, isMounted]\n  ) as any) as T\n}\n\n/**\n * This hook is a safe useState version which schedules state updates in microtasks\n * to prevent updating a component state while React is rendering different components\n * or when the component is not mounted anymore.\n */\nexport function useSafeState<S>(\n  initialState: S | (() => S)\n): [S, React.Dispatch<React.SetStateAction<S>>] {\n  const isMounted = useIsMounted()\n  const [state, setState] = React.useState(initialState)\n\n  const safeSetState = React.useCallback(\n    (value: React.SetStateAction<S>) => {\n      scheduleMicrotask(() => {\n        if (isMounted()) {\n          setState(value)\n        }\n      })\n    },\n    [isMounted]\n  )\n\n  return [state, safeSetState]\n}\n\nexport function useRerenderer() {\n  const [, setState] = useSafeState({})\n  return React.useCallback(() => setState({}), [setState])\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nfunction scheduleMicrotask(callback: () => void): void {\n  Promise.resolve()\n    .then(callback)\n    .catch(error =>\n      setTimeout(() => {\n        throw error\n      })\n    )\n}\n","import React from 'react'\n\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useSafeState } from './utils'\n\nexport function useIsFetching(): number {\n  const queryCache = useQueryCache()\n\n  const [isFetching, setIsFetching] = useSafeState(queryCache.isFetching)\n\n  React.useEffect(\n    () =>\n      queryCache.subscribe(() => {\n        setIsFetching(queryCache.isFetching)\n      }),\n    [queryCache, setIsFetching]\n  )\n\n  return isFetching\n}\n","import { MutationConfig } from '../core/types'\nimport { getDefaultedMutationConfig } from '../core/config'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\nexport function useDefaultedMutationConfig<\n  TResult,\n  TError,\n  TVariables,\n  TSnapshot\n>(\n  config?: MutationConfig<TResult, TError, TVariables, TSnapshot>\n): MutationConfig<TResult, TError, TVariables, TSnapshot> {\n  const contextConfig = useContextConfig()\n  const contextQueryCache = useQueryCache()\n  const queryCache = config?.queryCache || contextQueryCache\n  const queryCacheConfig = queryCache.getDefaultConfig()\n  return getDefaultedMutationConfig(queryCacheConfig, contextConfig, config, {\n    queryCache,\n  })\n}\n","import React from 'react'\n\nimport { useDefaultedMutationConfig } from './useDefaultedMutationConfig'\nimport { useGetLatest, useMountedCallback } from './utils'\nimport { Console, uid, getStatusProps } from '../core/utils'\nimport {\n  QueryStatus,\n  MutationResultPair,\n  MutationFunction,\n  MutationConfig,\n  MutateConfig,\n} from '../core/types'\n\n// TYPES\n\ntype Reducer<S, A> = (prevState: S, action: A) => S\n\ninterface State<TResult, TError> {\n  status: QueryStatus\n  data: TResult | undefined\n  error: TError | null\n  isIdle: boolean\n  isLoading: boolean\n  isSuccess: boolean\n  isError: boolean\n}\n\nenum ActionType {\n  Reset = 'Reset',\n  Loading = 'Loading',\n  Resolve = 'Resolve',\n  Reject = 'Reject',\n}\n\ninterface ResetAction {\n  type: ActionType.Reset\n}\n\ninterface LoadingAction {\n  type: ActionType.Loading\n}\n\ninterface ResolveAction<TResult> {\n  type: ActionType.Resolve\n  data: TResult\n}\n\ninterface RejectAction<TError> {\n  type: ActionType.Reject\n  error: TError\n}\n\ntype Action<TResult, TError> =\n  | ResetAction\n  | LoadingAction\n  | ResolveAction<TResult>\n  | RejectAction<TError>\n\n// HOOK\n\nconst getDefaultState = (): State<any, any> => ({\n  ...getStatusProps(QueryStatus.Idle),\n  data: undefined,\n  error: null,\n})\n\nfunction mutationReducer<TResult, TError>(\n  state: State<TResult, TError>,\n  action: Action<TResult, TError>\n): State<TResult, TError> {\n  switch (action.type) {\n    case ActionType.Reset:\n      return getDefaultState()\n    case ActionType.Loading:\n      return {\n        ...getStatusProps(QueryStatus.Loading),\n        data: undefined,\n        error: null,\n      }\n    case ActionType.Resolve:\n      return {\n        ...getStatusProps(QueryStatus.Success),\n        data: action.data,\n        error: null,\n      }\n    case ActionType.Reject:\n      return {\n        ...getStatusProps(QueryStatus.Error),\n        data: undefined,\n        error: action.error,\n      }\n    default:\n      return state\n  }\n}\n\nexport function useMutation<\n  TResult,\n  TError = unknown,\n  TVariables = undefined,\n  TSnapshot = unknown\n>(\n  mutationFn: MutationFunction<TResult, TVariables>,\n  config: MutationConfig<TResult, TError, TVariables, TSnapshot> = {}\n): MutationResultPair<TResult, TError, TVariables, TSnapshot> {\n  config = useDefaultedMutationConfig(config)\n  const getConfig = useGetLatest(config)\n\n  const [state, unsafeDispatch] = React.useReducer(\n    mutationReducer as Reducer<State<TResult, TError>, Action<TResult, TError>>,\n    null,\n    getDefaultState\n  )\n\n  const dispatch = useMountedCallback(unsafeDispatch)\n\n  const getMutationFn = useGetLatest(mutationFn)\n\n  const latestMutationRef = React.useRef<number>()\n\n  const mutate = React.useCallback(\n    async (\n      variables?: TVariables,\n      mutateConfig: MutateConfig<TResult, TError, TVariables, TSnapshot> = {}\n    ): Promise<TResult | undefined> => {\n      const config = getConfig()\n\n      const mutationId = uid()\n      latestMutationRef.current = mutationId\n\n      const isLatest = () => latestMutationRef.current === mutationId\n\n      let snapshotValue: TSnapshot | undefined\n\n      try {\n        dispatch({ type: ActionType.Loading })\n        snapshotValue = (await config.onMutate?.(variables!)) as TSnapshot\n\n        const data = await getMutationFn()(variables!)\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Resolve, data })\n        }\n\n        await config.onSuccess?.(data, variables!)\n        await mutateConfig.onSuccess?.(data, variables!)\n        await config.onSettled?.(data, null, variables!)\n        await mutateConfig.onSettled?.(data, null, variables!)\n\n        return data\n      } catch (error) {\n        Console.error(error)\n        await config.onError?.(error, variables!, snapshotValue!)\n        await mutateConfig.onError?.(error, variables!, snapshotValue!)\n        await config.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue as TSnapshot\n        )\n        await mutateConfig.onSettled?.(\n          undefined,\n          error,\n          variables!,\n          snapshotValue\n        )\n\n        if (isLatest()) {\n          dispatch({ type: ActionType.Reject, error })\n        }\n\n        if (mutateConfig.throwOnError ?? config.throwOnError) {\n          throw error\n        }\n      }\n    },\n    [dispatch, getConfig, getMutationFn]\n  )\n\n  const reset = React.useCallback(() => {\n    dispatch({ type: ActionType.Reset })\n  }, [dispatch])\n\n  React.useEffect(() => {\n    const { suspense, useErrorBoundary } = getConfig()\n\n    if ((useErrorBoundary ?? suspense) && state.error) {\n      throw state.error\n    }\n  }, [getConfig, state.error])\n\n  return [mutate, { ...state, reset }]\n}\n","import { QueryConfig } from '../core/types'\nimport { getDefaultedQueryConfig } from '../core/config'\nimport { useQueryCache } from './ReactQueryCacheProvider'\nimport { useContextConfig } from './ReactQueryConfigProvider'\n\nexport function useDefaultedQueryConfig<TResult, TError>(\n  config?: QueryConfig<TResult, TError>\n): QueryConfig<TResult, TError> {\n  const contextConfig = useContextConfig()\n  const contextQueryCache = useQueryCache()\n  const queryCache = config?.queryCache || contextQueryCache\n  const queryCacheConfig = queryCache.getDefaultConfig()\n  return getDefaultedQueryConfig(queryCacheConfig, contextConfig, config, {\n    queryCache,\n  })\n}\n","import React from 'react'\n\nimport { useRerenderer } from './utils'\nimport { QueryObserver } from '../core/queryObserver'\nimport { QueryResultBase, QueryObserverConfig } from '../core/types'\nimport { useDefaultedQueryConfig } from './useDefaultedQueryConfig'\n\nexport function useBaseQuery<TResult, TError>(\n  config: QueryObserverConfig<TResult, TError> = {}\n): QueryResultBase<TResult, TError> {\n  config = useDefaultedQueryConfig(config)\n\n  // Make a rerender function\n  const rerender = useRerenderer()\n\n  // Create query observer\n  const observerRef = React.useRef<QueryObserver<TResult, TError>>()\n  const firstRender = !observerRef.current\n  const observer = observerRef.current || new QueryObserver(config)\n  observerRef.current = observer\n\n  // Subscribe to the observer\n  React.useEffect(\n    () =>\n      observer.subscribe(() => {\n        rerender()\n      }),\n    [observer, rerender]\n  )\n\n  // Update config\n  if (!firstRender) {\n    observer.updateConfig(config)\n  }\n\n  const result = observer.getCurrentResult()\n\n  // Handle suspense\n  if (config.suspense || config.useErrorBoundary) {\n    const query = observer.getCurrentQuery()\n\n    if (result.isError && query.state.throwInErrorBoundary) {\n      throw result.error\n    }\n\n    if (config.enabled && config.suspense && !result.isSuccess) {\n      const unsubscribe = observer.subscribe()\n      throw observer.fetch().finally(unsubscribe)\n    }\n  }\n\n  return result\n}\n","import {\n  QueryConfig,\n  QueryFunction,\n  QueryKey,\n  QueryResult,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// TYPES\n\nexport interface UseQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: QueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useQuery<TResult, TError, TArgs extends TypedQueryFunctionArgs>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\nexport function useQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: QueryConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Object syntax\nexport function useQuery<TResult = unknown, TError = unknown>(\n  config: UseQueryObjectConfig<TResult, TError>\n): QueryResult<TResult, TError>\n\n// Implementation\nexport function useQuery<TResult, TError>(\n  ...args: any[]\n): QueryResult<TResult, TError> {\n  const config = getQueryArgs<TResult, TError>(args)[1]\n  return useBaseQuery<TResult, TError>(config)\n}\n","import {\n  PaginatedQueryConfig,\n  PaginatedQueryResult,\n  QueryFunction,\n  QueryKey,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// A paginated query is more like a \"lag\" query, which means\n// as the query key changes, we keep the results from the\n// last query and use them as placeholder data in the next one\n// We DON'T use it as initial data though. That's important\n\n// TYPES\n\nexport interface UsePaginatedQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: PaginatedQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function usePaginatedQuery<\n  TResult,\n  TError,\n  TArgs extends TypedQueryFunctionArgs\n>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: PaginatedQueryConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Object syntax\nexport function usePaginatedQuery<TResult = unknown, TError = unknown>(\n  config: UsePaginatedQueryObjectConfig<TResult, TError>\n): PaginatedQueryResult<TResult, TError>\n\n// Implementation\nexport function usePaginatedQuery<TResult, TError>(\n  ...args: any[]\n): PaginatedQueryResult<TResult, TError> {\n  const config = getQueryArgs<TResult, TError>(args)[1]\n  const result = useBaseQuery<TResult, TError>({\n    keepPreviousData: true,\n    ...config,\n  })\n  return {\n    ...result,\n    resolvedData: result.data,\n    latestData: result.isPreviousData ? undefined : result.data,\n  }\n}\n","import {\n  InfiniteQueryConfig,\n  InfiniteQueryResult,\n  QueryFunction,\n  QueryKey,\n  TypedQueryFunction,\n  TypedQueryFunctionArgs,\n} from '../core/types'\nimport { getQueryArgs } from '../core/utils'\nimport { useBaseQuery } from './useBaseQuery'\n\n// TYPES\n\nexport interface UseInfiniteQueryObjectConfig<TResult, TError> {\n  queryKey: QueryKey\n  queryFn?: QueryFunction<TResult>\n  config?: InfiniteQueryConfig<TResult, TError>\n}\n\n// HOOK\n\n// Parameter syntax with optional config\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Parameter syntax with query function and optional config\nexport function useInfiniteQuery<\n  TResult,\n  TError,\n  TArgs extends TypedQueryFunctionArgs\n>(\n  queryKey: QueryKey,\n  queryFn: TypedQueryFunction<TResult, TArgs>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  queryKey: QueryKey,\n  queryFn: QueryFunction<TResult>,\n  queryConfig?: InfiniteQueryConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Object syntax\nexport function useInfiniteQuery<TResult = unknown, TError = unknown>(\n  config: UseInfiniteQueryObjectConfig<TResult, TError>\n): InfiniteQueryResult<TResult, TError>\n\n// Implementation\nexport function useInfiniteQuery<TResult, TError>(\n  ...args: any[]\n): InfiniteQueryResult<TResult, TError> {\n  const config = getQueryArgs<TResult[], TError>(args)[1]\n  return useBaseQuery<TResult[], TError>({ ...config, infinite: true })\n}\n"]},"metadata":{},"sourceType":"module"}